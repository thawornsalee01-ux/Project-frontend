{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/asset-prefix.ts"],"sourcesContent":["import { InvariantError } from '../shared/lib/invariant-error'\n\nexport function getAssetPrefix() {\n  const currentScript = document.currentScript\n\n  if (!(currentScript instanceof HTMLScriptElement)) {\n    throw new InvariantError(\n      `Expected document.currentScript to be a <script> element. Received ${currentScript} instead.`\n    )\n  }\n\n  const { pathname } = new URL(currentScript.src)\n  const nextIndex = pathname.indexOf('/_next/')\n\n  if (nextIndex === -1) {\n    throw new InvariantError(\n      `Expected document.currentScript src to contain '/_next/'. Received ${currentScript.src} instead.`\n    )\n  }\n\n  return pathname.slice(0, nextIndex)\n}\n"],"names":["getAssetPrefix","currentScript","document","HTMLScriptElement","InvariantError","pathname","URL","src","nextIndex","indexOf","slice"],"mappings":";;;+BAEgBA,kBAAAA;;;eAAAA;;;gCAFe;AAExB,SAASA;IACd,MAAMC,gBAAgBC,SAASD,aAAa;IAE5C,IAAI,CAAEA,CAAAA,yBAAyBE,iBAAgB,GAAI;QACjD,MAAM,OAAA,cAEL,CAFK,IAAIC,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAc,SAAS,CAAC,GAD1F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAM,EAAEI,QAAQ,EAAE,GAAG,IAAIC,IAAIL,cAAcM,GAAG;IAC9C,MAAMC,YAAYH,SAASI,OAAO,CAAC;IAEnC,IAAID,cAAc,CAAC,GAAG;QACpB,MAAM,OAAA,cAEL,CAFK,IAAIJ,gBAAAA,cAAc,CACtB,CAAC,mEAAmE,EAAEH,cAAcM,GAAG,CAAC,SAAS,CAAC,GAD9F,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAOF,SAASK,KAAK,CAAC,GAAGF;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/set-attributes-from-props.ts"],"sourcesContent":["const DOMAttributeNames: Record<string, string> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv',\n  noModule: 'noModule',\n}\n\nconst ignoreProps = [\n  'onLoad',\n  'onReady',\n  'dangerouslySetInnerHTML',\n  'children',\n  'onError',\n  'strategy',\n  'stylesheets',\n]\n\nfunction isBooleanScriptAttribute(\n  attr: string\n): attr is 'async' | 'defer' | 'noModule' {\n  return ['async', 'defer', 'noModule'].includes(attr)\n}\n\nexport function setAttributesFromProps(el: HTMLElement, props: object) {\n  for (const [p, value] of Object.entries(props)) {\n    if (!props.hasOwnProperty(p)) continue\n    if (ignoreProps.includes(p)) continue\n\n    // we don't render undefined props to the DOM\n    if (value === undefined) {\n      continue\n    }\n\n    const attr = DOMAttributeNames[p] || p.toLowerCase()\n\n    if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n      // Correctly assign boolean script attributes\n      // https://github.com/vercel/next.js/pull/20748\n      ;(el as HTMLScriptElement)[attr] = !!value\n    } else {\n      el.setAttribute(attr, String(value))\n    }\n\n    // Remove falsy non-zero boolean attributes so they are correctly interpreted\n    // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n    if (\n      value === false ||\n      (el.tagName === 'SCRIPT' &&\n        isBooleanScriptAttribute(attr) &&\n        (!value || value === 'false'))\n    ) {\n      // Call setAttribute before, as we need to set and unset the attribute to override force async:\n      // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n      el.setAttribute(attr, '')\n      el.removeAttribute(attr)\n    }\n  }\n}\n"],"names":["setAttributesFromProps","DOMAttributeNames","acceptCharset","className","htmlFor","httpEquiv","noModule","ignoreProps","isBooleanScriptAttribute","attr","includes","el","props","p","value","Object","entries","hasOwnProperty","undefined","toLowerCase","tagName","setAttribute","String","removeAttribute"],"mappings":";;;+BAwBgBA,0BAAAA;;;eAAAA;;;AAxBhB,MAAMC,oBAA4C;IAChDC,eAAe;IACfC,WAAW;IACXC,SAAS;IACTC,WAAW;IACXC,UAAU;AACZ;AAEA,MAAMC,cAAc;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,yBACPC,IAAY;IAEZ,OAAO;QAAC;QAAS;QAAS;KAAW,CAACC,QAAQ,CAACD;AACjD;AAEO,SAAST,uBAAuBW,EAAe,EAAEC,KAAa;IACnE,KAAK,MAAM,CAACC,GAAGC,MAAM,IAAIC,OAAOC,OAAO,CAACJ,OAAQ;QAC9C,IAAI,CAACA,MAAMK,cAAc,CAACJ,IAAI;QAC9B,IAAIN,YAAYG,QAAQ,CAACG,IAAI;QAE7B,6CAA6C;QAC7C,IAAIC,UAAUI,WAAW;YACvB;QACF;QAEA,MAAMT,OAAOR,iBAAiB,CAACY,EAAE,IAAIA,EAAEM,WAAW;QAElD,IAAIR,GAAGS,OAAO,KAAK,YAAYZ,yBAAyBC,OAAO;YAC7D,6CAA6C;YAC7C,+CAA+C;;YAC7CE,EAAwB,CAACF,KAAK,GAAG,CAAC,CAACK;QACvC,OAAO;YACLH,GAAGU,YAAY,CAACZ,MAAMa,OAAOR;QAC/B;QAEA,6EAA6E;QAC7E,2GAA2G;QAC3G,IACEA,UAAU,SACTH,GAAGS,OAAO,KAAK,YACdZ,yBAAyBC,SACxB,CAAA,CAACK,SAASA,UAAU,OAAM,GAC7B;YACA,+FAA+F;YAC/F,2EAA2E;YAC3EH,GAAGU,YAAY,CAACZ,MAAM;YACtBE,GAAGY,eAAe,CAACd;QACrB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-bootstrap.ts"],"sourcesContent":["/**\n * Before starting the Next.js runtime and requiring any module, we need to make\n * sure the following scripts are executed in the correct order:\n * - Polyfills\n * - next/script with `beforeInteractive` strategy\n */\n\nimport { getAssetPrefix } from './asset-prefix'\nimport { setAttributesFromProps } from './set-attributes-from-props'\n\nconst version = process.env.__NEXT_VERSION\n\nwindow.next = {\n  version,\n  appDir: true,\n}\n\nfunction loadScriptsInSequence(\n  scripts: [src: string, props: { [prop: string]: any }][],\n  hydrate: () => void\n) {\n  if (!scripts || !scripts.length) {\n    return hydrate()\n  }\n\n  return scripts\n    .reduce((promise, [src, props]) => {\n      return promise.then(() => {\n        return new Promise<void>((resolve, reject) => {\n          const el = document.createElement('script')\n\n          if (props) {\n            setAttributesFromProps(el, props)\n          }\n\n          if (src) {\n            el.src = src\n            el.onload = () => resolve()\n            el.onerror = reject\n          } else if (props) {\n            el.innerHTML = props.children\n            setTimeout(resolve)\n          }\n\n          document.head.appendChild(el)\n        })\n      })\n    }, Promise.resolve())\n    .catch((err: Error) => {\n      console.error(err)\n      // Still try to hydrate even if there's an error.\n    })\n    .then(() => {\n      hydrate()\n    })\n}\n\nexport function appBootstrap(hydrate: (assetPrefix: string) => void) {\n  const assetPrefix = getAssetPrefix()\n\n  loadScriptsInSequence((self as any).__next_s, () => {\n    // If the static shell is being debugged, skip hydration if the\n    // `__nextppronly` query is present. This is only enabled when the\n    // environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is\n    // set to `1`. Otherwise the following is optimized out.\n    if (process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1') {\n      const search = new URLSearchParams(window.location.search)\n      if (\n        search.get('__nextppronly') === 'fallback' ||\n        search.get('__nextppronly') === '1'\n      ) {\n        console.warn(\n          `Skipping hydration due to __nextppronly=${search.get('__nextppronly')}`\n        )\n        return\n      }\n    }\n\n    hydrate(assetPrefix)\n  })\n}\n"],"names":["appBootstrap","version","process","env","__NEXT_VERSION","window","next","appDir","loadScriptsInSequence","scripts","hydrate","length","reduce","promise","src","props","then","Promise","resolve","reject","el","document","createElement","setAttributesFromProps","onload","onerror","innerHTML","children","setTimeout","head","appendChild","catch","err","console","error","assetPrefix","getAssetPrefix","self","__next_s","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","search","URLSearchParams","location","get","warn"],"mappings":"AAAA;;;;;CAKC,GA4DOE,QAAQC,GAAG,CAACoC,0CAA0C,KAAK,KAAK;AA5DvE;;;;+BAoDevC,gBAAAA;;;eAAAA;;;6BAlDe;wCACQ;AAEvC,MAAMC,UAAUC,QAAQC,GAAG,CAACC,cAAc;AAE1CC,OAAOC,IAAI,GAAG;IACZL;IACAM,QAAQ;AACV;AAEA,SAASC,sBACPC,OAAwD,EACxDC,OAAmB;IAEnB,IAAI,CAACD,WAAW,CAACA,QAAQE,MAAM,EAAE;QAC/B,OAAOD;IACT;IAEA,OAAOD,QACJG,MAAM,CAAC,CAACC,SAAS,CAACC,KAAKC,MAAM;QAC5B,OAAOF,QAAQG,IAAI,CAAC;YAClB,OAAO,IAAIC,QAAc,CAACC,SAASC;gBACjC,MAAMC,KAAKC,SAASC,aAAa,CAAC;gBAElC,IAAIP,OAAO;oBACTQ,CAAAA,GAAAA,wBAAAA,sBAAsB,EAACH,IAAIL;gBAC7B;gBAEA,IAAID,KAAK;oBACPM,GAAGN,GAAG,GAAGA;oBACTM,GAAGI,MAAM,GAAG,IAAMN;oBAClBE,GAAGK,OAAO,GAAGN;gBACf,OAAO,IAAIJ,OAAO;oBAChBK,GAAGM,SAAS,GAAGX,MAAMY,QAAQ;oBAC7BC,WAAWV;gBACb;gBAEAG,SAASQ,IAAI,CAACC,WAAW,CAACV;YAC5B;QACF;IACF,GAAGH,QAAQC,OAAO,IACjBa,KAAK,CAAC,CAACC;QACNC,QAAQC,KAAK,CAACF;IACd,iDAAiD;IACnD,GACChB,IAAI,CAAC;QACJN;IACF;AACJ;AAEO,SAASV,aAAaU,OAAsC;IACjE,MAAMyB,cAAcC,CAAAA,GAAAA,aAAAA,cAAc;IAElC5B,sBAAuB6B,KAAaC,QAAQ,EAAE;QAC5C,+DAA+D;QAC/D,kEAAkE;QAClE,uEAAuE;QACvE,wDAAwD;QACxD;;QAaA5B,QAAQyB;IACV;AACF","ignoreList":[0]}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/react-client-callbacks/report-global-error.ts"],"sourcesContent":["export const reportGlobalError =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : (error: unknown) => {\n        // TODO: Dispatch error event\n        globalThis.console.error(error)\n      }\n"],"names":["reportGlobalError","reportError","error","globalThis","console"],"mappings":";;;+BAAaA,qBAAAA;;;eAAAA;;;AAAN,MAAMA,oBACX,OAAOC,gBAAgB,aAEnB,AACAA,cACA,CAACC,2BAFyC;IAGxC,6BAA6B;IAC7BC,WAAWC,OAAO,CAACF,KAAK,CAACA;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/react-client-callbacks/on-recoverable-error.ts"],"sourcesContent":["// This module can be shared between both pages router and app router\n\nimport type { HydrationOptions } from 'react-dom/client'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport isError from '../../lib/is-error'\nimport { reportGlobalError } from './report-global-error'\n\nconst recoverableErrors = new WeakSet<Error>()\n\nexport function isRecoverableError(error: Error): boolean {\n  return recoverableErrors.has(error)\n}\n\nexport const onRecoverableError: HydrationOptions['onRecoverableError'] = (\n  error\n) => {\n  // x-ref: https://github.com/facebook/react/pull/28736\n  let cause = isError(error) && 'cause' in error ? error.cause : error\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(cause)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { decorateDevError } =\n      require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')\n    const causeError = decorateDevError(cause)\n    recoverableErrors.add(causeError)\n    cause = causeError\n  }\n\n  reportGlobalError(cause)\n}\n"],"names":["isRecoverableError","onRecoverableError","recoverableErrors","WeakSet","error","has","cause","isError","isBailoutToCSRError","process","env","NODE_ENV","decorateDevError","require","causeError","add","reportGlobalError"],"mappings":"AAAA,qEAAqE;AAqB/DS,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IAZfX,kBAAkB,EAAA;eAAlBA;;IAIHC,kBAAkB,EAAA;eAAlBA;;;;8BAVuB;;;;;kEAChB;mCACc;AAElC,MAAMC,oBAAoB,IAAIC;AAEvB,SAASH,mBAAmBI,KAAY;IAC7C,OAAOF,kBAAkBG,GAAG,CAACD;AAC/B;AAEO,MAAMH,qBAA6D,CACxEG;IAEA,sDAAsD;IACtD,IAAIE,QAAQC,CAAAA,GAAAA,SAAAA,OAAO,EAACH,UAAU,WAAWA,QAAQA,MAAME,KAAK,GAAGF;IAC/D,6EAA6E;IAC7E,IAAII,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;IAEhC,wCAA2C;QACzC,MAAM,EAAEM,gBAAgB,EAAE,GACxBC,QAAQ;QACV,MAAMC,aAAaF,iBAAiBN;QACpCJ,kBAAkBa,GAAG,CAACD;QACtBR,QAAQQ;IACV;IAEAE,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACV;AACpB","ignoreList":[0]}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status"],"mappings":";;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA","ignoreList":[0]}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode"],"mappings":";;;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAEDC,YAAY,EAAA;eAAZA;;IAgBIC,eAAe,EAAA;eAAfA;;;oCApBmB;AAE5B,MAAMF,sBAAsB;AAE5B,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;;AAgBL,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC","ignoreList":[0]}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError"],"mappings":";;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/lib/console.ts"],"sourcesContent":["import isError from '../../lib/is-error'\n\nfunction formatObject(arg: unknown, depth: number) {\n  switch (typeof arg) {\n    case 'object':\n      if (arg === null) {\n        return 'null'\n      } else if (Array.isArray(arg)) {\n        let result = '['\n        if (depth < 1) {\n          for (let i = 0; i < arg.length; i++) {\n            if (result !== '[') {\n              result += ','\n            }\n            if (Object.prototype.hasOwnProperty.call(arg, i)) {\n              result += formatObject(arg[i], depth + 1)\n            }\n          }\n        } else {\n          result += arg.length > 0 ? '...' : ''\n        }\n        result += ']'\n        return result\n      } else if (arg instanceof Error) {\n        return arg + ''\n      } else {\n        const keys = Object.keys(arg)\n        let result = '{'\n        if (depth < 1) {\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const desc = Object.getOwnPropertyDescriptor(arg, 'key')\n            if (desc && !desc.get && !desc.set) {\n              const jsonKey = JSON.stringify(key)\n              if (jsonKey !== '\"' + key + '\"') {\n                result += jsonKey + ': '\n              } else {\n                result += key + ': '\n              }\n              result += formatObject(desc.value, depth + 1)\n            }\n          }\n        } else {\n          result += keys.length > 0 ? '...' : ''\n        }\n        result += '}'\n        return result\n      }\n    case 'string':\n      return JSON.stringify(arg)\n    case 'number':\n    case 'bigint':\n    case 'boolean':\n    case 'symbol':\n    case 'undefined':\n    case 'function':\n    default:\n      return String(arg)\n  }\n}\n\nexport function formatConsoleArgs(args: unknown[]): string {\n  let message: string\n  let idx: number\n  if (typeof args[0] === 'string') {\n    message = args[0]\n    idx = 1\n  } else {\n    message = ''\n    idx = 0\n  }\n  let result = ''\n  let startQuote = false\n  for (let i = 0; i < message.length; ++i) {\n    const char = message[i]\n    if (char !== '%' || i === message.length - 1 || idx >= args.length) {\n      result += char\n      continue\n    }\n\n    const code = message[++i]\n    switch (code) {\n      case 'c': {\n        // TODO: We should colorize with HTML instead of turning into a string.\n        // Ignore for now.\n        result = startQuote ? `${result}]` : `[${result}`\n        startQuote = !startQuote\n        idx++\n        break\n      }\n      case 'O':\n      case 'o': {\n        result += formatObject(args[idx++], 0)\n        break\n      }\n      case 'd':\n      case 'i': {\n        result += parseInt(args[idx++] as any, 10)\n        break\n      }\n      case 'f': {\n        result += parseFloat(args[idx++] as any)\n        break\n      }\n      case 's': {\n        result += String(args[idx++])\n        break\n      }\n      default:\n        result += '%' + code\n    }\n  }\n\n  for (; idx < args.length; idx++) {\n    result += (idx > 0 ? ' ' : '') + formatObject(args[idx], 0)\n  }\n\n  return result\n}\n\nexport function parseConsoleArgs(args: unknown[]): {\n  environmentName: string | null\n  error: Error | null\n} {\n  // See\n  // https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93\n  //\n  // Logs replayed from the server look like this:\n  // [\n  //   \"%c%s%c%o\\n\\n%s\\n\\n%s\\n\",\n  //   \"background: #e6e6e6; ...\",\n  //   \" Server \", // can also be e.g. \" Prerender \"\n  //   \"\",\n  //   Error,\n  //   \"The above error occurred in the <Page> component.\",\n  //   ...\n  // ]\n  if (\n    args.length > 3 &&\n    typeof args[0] === 'string' &&\n    args[0].startsWith('%c%s%c') &&\n    typeof args[1] === 'string' &&\n    typeof args[2] === 'string' &&\n    typeof args[3] === 'string'\n  ) {\n    const environmentName = args[2]\n    const maybeError = args[4]\n\n    return {\n      environmentName: environmentName.trim(),\n      error: isError(maybeError) ? maybeError : null,\n    }\n  }\n\n  return {\n    environmentName: null,\n    error: null,\n  }\n}\n"],"names":["formatConsoleArgs","parseConsoleArgs","formatObject","arg","depth","Array","isArray","result","i","length","Object","prototype","hasOwnProperty","call","Error","keys","key","desc","getOwnPropertyDescriptor","get","set","jsonKey","JSON","stringify","value","String","args","message","idx","startQuote","char","code","parseInt","parseFloat","startsWith","environmentName","maybeError","trim","error","isError"],"mappings":";;;;;;;;;;;;;;IA6DgBA,iBAAiB,EAAA;eAAjBA;;IA2DAC,gBAAgB,EAAA;eAAhBA;;;;kEAxHI;AAEpB,SAASC,aAAaC,GAAY,EAAEC,KAAa;IAC/C,OAAQ,OAAOD;QACb,KAAK;YACH,IAAIA,QAAQ,MAAM;gBAChB,OAAO;YACT,OAAO,IAAIE,MAAMC,OAAO,CAACH,MAAM;gBAC7B,IAAII,SAAS;gBACb,IAAIH,QAAQ,GAAG;oBACb,IAAK,IAAII,IAAI,GAAGA,IAAIL,IAAIM,MAAM,EAAED,IAAK;wBACnC,IAAID,WAAW,KAAK;4BAClBA,UAAU;wBACZ;wBACA,IAAIG,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACV,KAAKK,IAAI;4BAChDD,UAAUL,aAAaC,GAAG,CAACK,EAAE,EAAEJ,QAAQ;wBACzC;oBACF;gBACF,OAAO;oBACLG,UAAUJ,IAAIM,MAAM,GAAG,IAAI,QAAQ;gBACrC;gBACAF,UAAU;gBACV,OAAOA;YACT,OAAO,IAAIJ,eAAeW,OAAO;gBAC/B,OAAOX,MAAM;YACf,OAAO;gBACL,MAAMY,OAAOL,OAAOK,IAAI,CAACZ;gBACzB,IAAII,SAAS;gBACb,IAAIH,QAAQ,GAAG;oBACb,IAAK,IAAII,IAAI,GAAGA,IAAIO,KAAKN,MAAM,EAAED,IAAK;wBACpC,MAAMQ,MAAMD,IAAI,CAACP,EAAE;wBACnB,MAAMS,OAAOP,OAAOQ,wBAAwB,CAACf,KAAK;wBAClD,IAAIc,QAAQ,CAACA,KAAKE,GAAG,IAAI,CAACF,KAAKG,GAAG,EAAE;4BAClC,MAAMC,UAAUC,KAAKC,SAAS,CAACP;4BAC/B,IAAIK,YAAY,MAAML,MAAM,KAAK;gCAC/BT,UAAUc,UAAU;4BACtB,OAAO;gCACLd,UAAUS,MAAM;4BAClB;4BACAT,UAAUL,aAAae,KAAKO,KAAK,EAAEpB,QAAQ;wBAC7C;oBACF;gBACF,OAAO;oBACLG,UAAUQ,KAAKN,MAAM,GAAG,IAAI,QAAQ;gBACtC;gBACAF,UAAU;gBACV,OAAOA;YACT;QACF,KAAK;YACH,OAAOe,KAAKC,SAAS,CAACpB;QACxB,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL;YACE,OAAOsB,OAAOtB;IAClB;AACF;AAEO,SAASH,kBAAkB0B,IAAe;IAC/C,IAAIC;IACJ,IAAIC;IACJ,IAAI,OAAOF,IAAI,CAAC,EAAE,KAAK,UAAU;QAC/BC,UAAUD,IAAI,CAAC,EAAE;QACjBE,MAAM;IACR,OAAO;QACLD,UAAU;QACVC,MAAM;IACR;IACA,IAAIrB,SAAS;IACb,IAAIsB,aAAa;IACjB,IAAK,IAAIrB,IAAI,GAAGA,IAAImB,QAAQlB,MAAM,EAAE,EAAED,EAAG;QACvC,MAAMsB,OAAOH,OAAO,CAACnB,EAAE;QACvB,IAAIsB,SAAS,OAAOtB,MAAMmB,QAAQlB,MAAM,GAAG,KAAKmB,OAAOF,KAAKjB,MAAM,EAAE;YAClEF,UAAUuB;YACV;QACF;QAEA,MAAMC,OAAOJ,OAAO,CAAC,EAAEnB,EAAE;QACzB,OAAQuB;YACN,KAAK;gBAAK;oBACR,uEAAuE;oBACvE,kBAAkB;oBAClBxB,SAASsB,aAAa,GAAGtB,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAEA,QAAQ;oBACjDsB,aAAa,CAACA;oBACdD;oBACA;gBACF;YACA,KAAK;YACL,KAAK;gBAAK;oBACRrB,UAAUL,aAAawB,IAAI,CAACE,MAAM,EAAE;oBACpC;gBACF;YACA,KAAK;YACL,KAAK;gBAAK;oBACRrB,UAAUyB,SAASN,IAAI,CAACE,MAAM,EAAS;oBACvC;gBACF;YACA,KAAK;gBAAK;oBACRrB,UAAU0B,WAAWP,IAAI,CAACE,MAAM;oBAChC;gBACF;YACA,KAAK;gBAAK;oBACRrB,UAAUkB,OAAOC,IAAI,CAACE,MAAM;oBAC5B;gBACF;YACA;gBACErB,UAAU,MAAMwB;QACpB;IACF;IAEA,MAAOH,MAAMF,KAAKjB,MAAM,EAAEmB,MAAO;QAC/BrB,UAAWqB,CAAAA,MAAM,IAAI,MAAM,EAAC,IAAK1B,aAAawB,IAAI,CAACE,IAAI,EAAE;IAC3D;IAEA,OAAOrB;AACT;AAEO,SAASN,iBAAiByB,IAAe;IAI9C,MAAM;IACN,wJAAwJ;IACxJ,EAAE;IACF,gDAAgD;IAChD,IAAI;IACJ,8BAA8B;IAC9B,gCAAgC;IAChC,kDAAkD;IAClD,QAAQ;IACR,WAAW;IACX,yDAAyD;IACzD,QAAQ;IACR,IAAI;IACJ,IACEA,KAAKjB,MAAM,GAAG,KACd,OAAOiB,IAAI,CAAC,EAAE,KAAK,YACnBA,IAAI,CAAC,EAAE,CAACQ,UAAU,CAAC,aACnB,OAAOR,IAAI,CAAC,EAAE,KAAK,YACnB,OAAOA,IAAI,CAAC,EAAE,KAAK,YACnB,OAAOA,IAAI,CAAC,EAAE,KAAK,UACnB;QACA,MAAMS,kBAAkBT,IAAI,CAAC,EAAE;QAC/B,MAAMU,aAAaV,IAAI,CAAC,EAAE;QAE1B,OAAO;YACLS,iBAAiBA,gBAAgBE,IAAI;YACrCC,OAAOC,CAAAA,GAAAA,SAAAA,OAAO,EAACH,cAAcA,aAAa;QAC5C;IACF;IAEA,OAAO;QACLD,iBAAiB;QACjBG,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 632, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-globals.ts"],"sourcesContent":["// imports polyfill from `@next/polyfill-module` after build.\nimport '../build/polyfills/polyfill-module'\n\n// Only setup devtools in development\nif (process.env.NODE_ENV !== 'production') {\n  require('../next-devtools/userspace/app/app-dev-overlay-setup') as typeof import('../next-devtools/userspace/app/app-dev-overlay-setup')\n}\n"],"names":["process","env","NODE_ENV","require"],"mappings":"AAAA,6DAA6D;AAIzDA,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;AAD7B,qCAAqC;AACrC,wCAA2C;;AAE3C","ignoreList":[0]}},
    {"offset": {"line": 654, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/app-router-headers.ts"],"sourcesContent":["export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n"],"names":["ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACaA,aAAa,EAAA;eAAbA;;IAiBAC,cAAc,EAAA;eAAdA;;IAeAC,4BAA4B,EAAA;eAA5BA;;IAJAC,wBAAwB,EAAA;eAAxBA;;IAfAC,4BAA4B,EAAA;eAA5BA;;IADAC,uBAAuB,EAAA;eAAvBA;;IAsBAC,2BAA2B,EAAA;eAA3BA;;IAHAC,wBAAwB,EAAA;eAAxBA;;IAEAC,sBAAsB,EAAA;eAAtBA;;IAJAC,0BAA0B,EAAA;eAA1BA;;IACAC,2BAA2B,EAAA;eAA3BA;;IAzBAC,2BAA2B,EAAA;eAA3BA;;IAKAC,mCAAmC,EAAA;eAAnCA;;IAiBAC,6BAA6B,EAAA;eAA7BA;;IAvBAC,6BAA6B,EAAA;eAA7BA;;IAqBAC,oBAAoB,EAAA;eAApBA;;IAXAC,QAAQ,EAAA;eAARA;;IACAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,UAAU,EAAA;eAAVA;;;AAAN,MAAMA,aAAa;AACnB,MAAMlB,gBAAgB;AAItB,MAAMc,gCAAgC;AACtC,MAAMH,8BAA8B;AAKpC,MAAMC,sCACX;AACK,MAAMP,0BAA0B;AAChC,MAAMD,+BAA+B;AACrC,MAAMY,WAAW;AACjB,MAAMC,0BAA0B;AAEhC,MAAMhB,iBAAiB;IAC5BiB;IACAJ;IACAH;IACAN;IACAO;CACD;AAEM,MAAMG,uBAAuB;AAE7B,MAAMF,gCAAgC;AACtC,MAAMV,2BAA2B;AACjC,MAAMM,6BAA6B;AACnC,MAAMC,8BAA8B;AACpC,MAAMH,2BAA2B;AACjC,MAAML,+BAA+B;AACrC,MAAMM,yBAAyB;AAC/B,MAAMF,8BAA8B","ignoreList":[0]}},
    {"offset": {"line": 779, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/navigation-untracked.ts"],"sourcesContent":["import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters that\n * would cause the pathname to be dynamic. It's used to trigger a different\n * render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams(): boolean {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workUnitAsyncStorage } =\n      require('../../server/app-render/work-unit-async-storage.external') as typeof import('../../server/app-render/work-unit-async-storage.external')\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) return false\n\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        return fallbackParams ? fallbackParams.size > 0 : false\n      case 'prerender-legacy':\n      case 'request':\n      case 'prerender-runtime':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n\n    return false\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n"],"names":["useUntrackedPathname","hasFallbackRouteParams","window","workUnitAsyncStorage","require","workUnitStore","getStore","type","fallbackParams","fallbackRouteParams","size","useContext","PathnameContext"],"mappings":";;;+BAqDgBA,wBAAAA;;;eAAAA;;;uBArDW;iDACK;AAEhC;;;;;;CAMC,GACD,SAASC;IACP,IAAI,OAAOC,WAAW,aAAa;QACjC,iEAAiE;QACjE,MAAM,EAAEC,oBAAoB,EAAE,GAC5BC,QAAQ;QAEV,MAAMC,gBAAgBF,qBAAqBG,QAAQ;QACnD,IAAI,CAACD,eAAe,OAAO;QAE3B,OAAQA,cAAcE,IAAI;YACxB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,MAAMC,iBAAiBH,cAAcI,mBAAmB;gBACxD,OAAOD,iBAAiBA,eAAeE,IAAI,GAAG,IAAI;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACH;YACF;gBACEL;QACJ;QAEA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAASL;IACd,qEAAqE;IACrE,8EAA8E;IAC9E,8EAA8E;IAC9E,uBAAuB;IACvB,IAAIC,0BAA0B;QAC5B,OAAO;IACT;IAEA,2EAA2E;IAC3E,qDAAqD;IACrD,sDAAsD;IACtD,OAAOU,CAAAA,GAAAA,OAAAA,UAAU,EAACC,iCAAAA,eAAe;AACnC","ignoreList":[0]}},
    {"offset": {"line": 846, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;+BAAgBA,qBAAAA;;;eAAAA;;;AAAT,SAASA,kBACdC,GAA8C,EAC9CC,cAAuB,IAAI;IAE3B,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/nav-failure-handler.ts"],"sourcesContent":["import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n"],"names":["handleHardNavError","useNavFailureHandler","error","window","next","__pendingUrl","createHrefFromUrl","URL","location","href","console","toString","process","env","__NEXT_APP_NAV_FAIL_HANDLING","useEffect","uncaughtExceptionHandler","evt","reason","addEventListener","removeEventListener"],"mappings":"AAsBMY,QAAQC,GAAG,CAACC,4BAA4B,EAAE;;;;;;;;;;;;;;;;IAnBhCd,kBAAkB,EAAA;eAAlBA;;IAkBAC,oBAAoB,EAAA;eAApBA;;;uBArBU;mCACQ;AAE3B,SAASD,mBAAmBE,KAAc;IAC/C,IACEA,SACA,OAAOC,WAAW,eAClBA,OAAOC,IAAI,CAACC,YAAY,IACxBC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC,IAAIC,IAAIJ,OAAOK,QAAQ,CAACC,IAAI,OAC5CH,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH,OAAOC,IAAI,CAACC,YAAY,GAC5C;QACAK,QAAQR,KAAK,CACX,CAAC,iEAAiE,CAAC,EACnEA;QAEFC,OAAOK,QAAQ,CAACC,IAAI,GAAGN,OAAOC,IAAI,CAACC,YAAY,CAACM,QAAQ;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAASV;IACd;;AAwBF","ignoreList":[0]}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/handle-isr-error.tsx"],"sourcesContent":["const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isStaticGeneration) {\n      if (error) {\n        console.error(error)\n      }\n      throw error\n    }\n  }\n\n  return null\n}\n"],"names":["HandleISRError","workAsyncStorage","window","require","undefined","error","store","getStore","isStaticGeneration","console"],"mappings":";;;+BAUgBA,kBAAAA;;;eAAAA;;;AAVhB,MAAMC,mBACJ,OAAOC,WAAW,cAEZC,QAAQ,+HACRF,gBAAgB,GAClBG;AAKC,SAASJ,eAAe,EAAEK,KAAK,EAAkB;IACtD,IAAIJ,kBAAkB;QACpB,MAAMK,QAAQL,iBAAiBM,QAAQ;QACvC,IAAID,OAAOE,oBAAoB;YAC7B,IAAIH,OAAO;gBACTI,QAAQJ,KAAK,CAACA;YAChB;YACA,MAAMA;QACR;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/error-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","window","isBot","navigator","userAgent","React","Component","constructor","props","reset","setState","error","state","previousPathname","pathname","getDerivedStateFromError","isNextRouterError","getDerivedStateFromProps","process","env","__NEXT_APP_NAV_FAIL_HANDLING","handleHardNavError","render","HandleISRError","errorStyles","errorScripts","this","errorComponent","children","useUntrackedPathname"],"mappings":"AAiEQoB,QAAQC,GAAG,CAACC,4BAA4B,EAAE;AAjElD;;;;;;;;;;;;;;;;IAgIgBtB,aAAa,EAAA;eAAbA;;IA5FHC,oBAAoB,EAAA;eAApBA;;;;;gEAlCmB;qCACK;mCACH;mCACC;gCACJ;uBACT;AAEtB,MAAMC,iBACJ,OAAOC,WAAW,eAAeC,CAAAA,GAAAA,OAAAA,KAAK,EAACD,OAAOE,SAAS,CAACC,SAAS;AA0B5D,MAAML,6BAA6BM,OAAAA,OAAK,CAACC,SAAS;IAIvDC,YAAYC,KAAgC,CAAE;QAC5C,KAAK,CAACA,QAAAA,IAAAA,CAoDRC,KAAAA,GAAQ;YACN,IAAI,CAACC,QAAQ,CAAC;gBAAEC,OAAO;YAAK;QAC9B;QArDE,IAAI,CAACC,KAAK,GAAG;YAAED,OAAO;YAAME,kBAAkB,IAAI,CAACL,KAAK,CAACM,QAAQ;QAAC;IACpE;IAEA,OAAOC,yBAAyBJ,KAAY,EAAE;QAC5C,IAAIK,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACL,QAAQ;YAC5B,+DAA+D;YAC/D,4GAA4G;YAC5G,MAAMA;QACR;QAEA,OAAO;YAAEA;QAAM;IACjB;IAEA,OAAOM,yBACLT,KAAgC,EAChCI,KAAgC,EACE;QAClC,MAAM,EAAED,KAAK,EAAE,GAAGC;QAElB,iCAAiC;QACjC,8CAA8C;QAC9C,iDAAiD;QACjD,6CAA6C;QAC7C;;QAUA;;;;;KAKC,GACD,IAAIJ,MAAMM,QAAQ,KAAKF,MAAMC,gBAAgB,IAAID,MAAMD,KAAK,EAAE;YAC5D,OAAO;gBACLA,OAAO;gBACPE,kBAAkBL,MAAMM,QAAQ;YAClC;QACF;QACA,OAAO;YACLH,OAAOC,MAAMD,KAAK;YAClBE,kBAAkBL,MAAMM,QAAQ;QAClC;IACF;IAMA,yIAAyI;IACzIQ,SAA0B;QACxB,uFAAuF;QACvF,iHAAiH;QACjH,IAAI,IAAI,CAACV,KAAK,CAACD,KAAK,IAAI,CAACX,gBAAgB;YACvC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;kCACE,CAAA,GAAA,YAAA,GAAA,EAACuB,gBAAAA,cAAc,EAAA;wBAACZ,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;;oBACtC,IAAI,CAACH,KAAK,CAACgB,WAAW;oBACtB,IAAI,CAAChB,KAAK,CAACiB,YAAY;kCACxB,CAAA,GAAA,YAAA,GAAA,EAACC,IAAI,CAAClB,KAAK,CAACmB,cAAc,EAAA;wBACxBhB,OAAO,IAAI,CAACC,KAAK,CAACD,KAAK;wBACvBF,OAAO,IAAI,CAACA,KAAK;;;;QAIzB;QAEA,OAAO,IAAI,CAACD,KAAK,CAACoB,QAAQ;IAC5B;AACF;AAWO,SAAS9B,cAAc,EAC5B6B,cAAc,EACdH,WAAW,EACXC,YAAY,EACZG,QAAQ,EAGT;IACC,6EAA6E;IAC7E,qEAAqE;IACrE,wEAAwE;IACxE,oEAAoE;IACpE,MAAMd,WAAWe,CAAAA,GAAAA,qBAAAA,oBAAoB;IACrC,IAAIF,gBAAgB;QAClB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAAC5B,sBAAAA;YACCe,UAAUA;YACVa,gBAAgBA;YAChBH,aAAaA;YACbC,cAAcA;sBAEbG;;IAGP;IAEA,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAAA,YAAA,QAAA,EAAA;kBAAGA;;AACZ","ignoreList":[0]}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/builtin/global-error.tsx"],"sourcesContent":["'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n"],"names":["styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","DefaultGlobalError","digest","html","id","head","body","HandleISRError","div","style","h2","window","location","hostname","p"],"mappings":";;;+BAmDA,AADA,2CAC2C,qCADqC;AAEhF,WAAA;;;eAAA;;;;gCAlD+B;AAE/B,MAAMA,SAAS;IACbC,OAAO;QACL,0FAA0F;QAC1FC,YACE;QACFC,QAAQ;QACRC,WAAW;QACXC,SAAS;QACTC,eAAe;QACfC,YAAY;QACZC,gBAAgB;IAClB;IACAC,MAAM;QACJC,UAAU;QACVC,YAAY;QACZC,YAAY;QACZC,QAAQ;IACV;AACF;AAKA,SAASC,mBAAmB,EAAEb,KAAK,EAAkB;IACnD,MAAMc,SAA6Bd,OAAOc;IAC1C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;QAAKC,IAAG;;0BACP,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA,CAAAA;0BACD,CAAA,GAAA,YAAA,IAAA,EAACC,QAAAA;;kCACC,CAAA,GAAA,YAAA,GAAA,EAACC,gBAAAA,cAAc,EAAA;wBAACnB,OAAOA;;kCACvB,CAAA,GAAA,YAAA,GAAA,EAACoB,OAAAA;wBAAIC,OAAOtB,OAAOC,KAAK;kCACtB,WAAA,GAAA,CAAA,GAAA,YAAA,IAAA,EAACoB,OAAAA;;8CACC,CAAA,GAAA,YAAA,IAAA,EAACE,MAAAA;oCAAGD,OAAOtB,OAAOS,IAAI;;wCAAE;wCACAM,SAAS,WAAW;wCAAS;wCACvBS,OAAOC,QAAQ,CAACC,QAAQ;wCAAC;wCAAU;wCAC9DX,SAAS,gBAAgB;wCAAkB;;;gCAG7CA,SAAAA,WAAAA,GAAS,CAAA,GAAA,YAAA,GAAA,EAACY,KAAAA;oCAAEL,OAAOtB,OAAOS,IAAI;8CAAG,CAAC,QAAQ,EAAEM,QAAQ;qCAAQ;;;;;;;;AAMzE;MAIA,WAAeD","ignoreList":[0]}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},
    {"offset": {"line": 1207, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/react-client-callbacks/error-boundary-callbacks.ts"],"sourcesContent":["// This file is only used in app router due to the specific error state handling.\n\nimport type { ErrorInfo } from 'react'\nimport { isNextRouterError } from '../components/is-next-router-error'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { reportGlobalError } from './report-global-error'\nimport { ErrorBoundaryHandler } from '../components/error-boundary'\nimport DefaultErrorBoundary from '../components/builtin/global-error'\n\nconst devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))\n    : {\n        decorateDevError: (error: unknown) => error as Error,\n        handleClientError: () => {},\n        originConsoleError: console.error.bind(console),\n      }\n\nexport function onCaughtError(\n  thrownValue: unknown,\n  errorInfo: ErrorInfo & { errorBoundary?: React.Component }\n) {\n  const errorBoundaryComponent = errorInfo.errorBoundary?.constructor\n\n  let isImplicitErrorBoundary\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { AppDevOverlayErrorBoundary } =\n      require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')\n\n    isImplicitErrorBoundary =\n      errorBoundaryComponent === AppDevOverlayErrorBoundary\n  }\n\n  isImplicitErrorBoundary =\n    isImplicitErrorBoundary ||\n    (errorBoundaryComponent === ErrorBoundaryHandler &&\n      (errorInfo.errorBoundary! as InstanceType<typeof ErrorBoundaryHandler>)\n        .props.errorComponent === DefaultErrorBoundary)\n\n  // Skip the segment explorer triggered error\n  if (process.env.NODE_ENV !== 'production') {\n    const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =\n      require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n    if (\n      thrownValue instanceof Error &&\n      thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n  }\n\n  if (isImplicitErrorBoundary) {\n    // We don't consider errors caught unless they're caught by an explicit error\n    // boundary. The built-in ones are considered implicit.\n    // This mimics how the same app would behave without Next.js.\n    return onUncaughtError(thrownValue)\n  }\n\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const errorBoundaryName =\n      // read react component displayName\n      (errorBoundaryComponent as any)?.displayName ||\n      errorBoundaryComponent?.name ||\n      'Unknown'\n\n    const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1]\n\n    // Match chrome or safari stack trace\n    const matches =\n      // regex to match the function name in the stack trace\n      // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n      // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n      componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? []\n    const componentThatErroredName = matches[1] || matches[2] || 'Unknown'\n\n    // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n    const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`\n    const componentErrorMessage = componentThatErroredName\n      ? `The above error occurred in the <${componentThatErroredName}> component.`\n      : `The above error occurred in one of your components.`\n\n    const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // Log and report the error with location but without modifying the error stack\n    devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation)\n\n    devToolErrorMod.handleClientError(error)\n  } else {\n    devToolErrorMod.originConsoleError(thrownValue)\n  }\n}\n\nexport function onUncaughtError(thrownValue: unknown) {\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n    reportGlobalError(error)\n  } else {\n    reportGlobalError(thrownValue)\n  }\n}\n"],"names":["onCaughtError","onUncaughtError","devToolErrorMod","process","env","NODE_ENV","require","decorateDevError","error","handleClientError","originConsoleError","console","bind","thrownValue","errorInfo","errorBoundaryComponent","errorBoundary","constructor","isImplicitErrorBoundary","AppDevOverlayErrorBoundary","ErrorBoundaryHandler","props","errorComponent","DefaultErrorBoundary","SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE","Error","message","isBailoutToCSRError","isNextRouterError","errorBoundaryName","displayName","name","componentThatErroredFrame","componentStack","split","matches","match","componentThatErroredName","errorBoundaryMessage","componentErrorMessage","errorLocation","reportGlobalError"],"mappings":"AAAA,iFAAiF;AAU/EG,QAAQC,GAAG,CAACC,QAAQ,KAAK,eACpBC,QAAQ;;;;;;;;;;;;;;;;IAOCN,aAAa,EAAA;eAAbA;;IA+EAC,eAAe,EAAA;eAAfA;;;;mCA9FkB;8BACE;;;;;mCACF;+BACG;sEACJ;AAEjC,MAAMC,6LAGA;AAMC,SAASF,cACda,WAAoB,EACpBC,SAA0D;IAE1D,MAAMC,yBAAyBD,UAAUE,aAAa,EAAEC;IAExD,IAAIC;IAEJ,IAAIf,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEc,0BAA0B,EAAE,GAClCb,QAAQ;QAEVY,0BACEH,2BAA2BI;IAC/B;IAEAD,0BACEA,2BACCH,2BAA2BK,eAAAA,oBAAoB,IAC7CN,UAAUE,aAAa,CACrBK,KAAK,CAACC,cAAc,KAAKC,aAAAA,OAAoB;IAEpD,4CAA4C;IAC5C,IAAIpB,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEmB,wCAAwC,EAAE,GAChDlB,QAAQ;QACV,IACEO,uBAAuBY,SACvBZ,YAAYa,OAAO,KAAKF,0CACxB;YACA;QACF;IACF;IAEA,IAAIN,yBAAyB;QAC3B,6EAA6E;QAC7E,uDAAuD;QACvD,6DAA6D;QAC7D,OAAOjB,gBAAgBY;IACzB;IAEA,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMwB,oBAEJ,AADA,AACCd,wBAAgCe,WADE,IAEnCf,wBAAwBgB,QACxB;QAEF,MAAMC,4BAA4BlB,WAAWmB,gBAAgBC,MAAM,KAAK,CAAC,EAAE;QAE3E,qCAAqC;QACrC,MAAMC,UACJ,AACA,sDADsD,+CAC+C;QACrG,gGAAgG;QAChGH,2BAA2BI,MAAM,4BAA4B,EAAE;QACjE,MAAMC,2BAA2BF,OAAO,CAAC,EAAE,IAAIA,OAAO,CAAC,EAAE,IAAI;QAE7D,iIAAiI;QACjI,MAAMG,uBAAuB,CAAC,uBAAuB,EAAET,kBAAkB,iBAAiB,CAAC;QAC3F,MAAMU,wBAAwBF,uCAC1B,CAAC,iCAAiC,EAAEA,yBAAyB,YAAY,CAAC,GAC1E,CAAC,mDAAmD,CAAC;QAEzD,MAAMG,gBAAgB,GAAGD,sBAAsB,CAAC,EAAED,sBAAsB;QACxE,MAAM9B,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,+EAA+E;QAC/EX,gBAAgBQ,kBAAkB,CAAC,YAAYG,aAAa2B;QAE5DtC,gBAAgBO,iBAAiB,CAACD;IACpC,OAAO;;AAGT;AAEO,SAASP,gBAAgBY,WAAoB;IAClD,6EAA6E;IAC7E,IAAIc,CAAAA,GAAAA,cAAAA,mBAAmB,EAACd,gBAAgBe,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACf,cAAc;IAExE,IAAIV,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAMG,QAAQN,gBAAgBK,gBAAgB,CAACM;QAE/C,oFAAoF;QACpF4B,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACjC;IACpB,OAAO;;AAGT","ignoreList":[0]}},
    {"offset": {"line": 1305, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind"],"mappings":";;;;;;;;;;;;;;;;;;;IAWaA,kBAAkB,EAAA;eAAlBA;;IAHAC,eAAe,EAAA;eAAfA;;IADAC,cAAc,EAAA;eAAdA;;IAEAC,cAAc,EAAA;eAAdA;;IAGAC,oBAAoB,EAAA;eAApBA;;IAFAC,mBAAmB,EAAA;eAAnBA;;IA8IDC,YAAY,EAAA;eAAZA;;;AAjJL,MAAMJ,iBAAiB;AACvB,MAAMD,kBAAkB;AACxB,MAAME,iBAAiB;AACvB,MAAME,sBAAsB;AAC5B,MAAML,qBAAqB;AAC3B,MAAMI,uBAAuB;AA4I7B,IAAKE,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA","ignoreList":[0]}},
    {"offset": {"line": 1369, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/use-action-queue.ts"],"sourcesContent":["import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n"],"names":["dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","isThenable","promiseWithDebugInfo","get","undefined","debugInfo","Promise","resolve","then","asyncState","push","_debugInfo","set","use"],"mappings":"AAwBgBM,QAAQC,GAAG,CAACC,QAAQ;;;;;;;;;;;;;;;;IATpBR,uBAAuB,EAAA;eAAvBA;;IAeAC,cAAc,EAAA;eAAdA;;;;iEA7BoB;4BACT;AAQ3B,6EAA6E;AAC7E,+EAA+E;AAC/E,cAAc;AACd,IAAIC,WAA4C;AAEzC,SAASF,wBAAwBG,MAAsB;IAC5D,IAAID,aAAa,MAAM;QACrB,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,4EADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACAF,SAASC;AACX;AAEA,MAAME,8DAAmC;AACzC,MAAMI,wBAGFJ,uCAAU,IAAIK,YAAa;AAExB,SAAST,eACdU,WAAiC;IAEjC,MAAM,CAACC,OAAOC,SAAS,GAAGC,OAAAA,OAAK,CAACC,QAAQ,CAAeJ,YAAYC,KAAK;IAExE,6EAA6E;IAC7E,6EAA6E;IAC7E,yEAAyE;IACzE,uEAAuE;IACvE,4EAA4E;IAC5E,4EAA4E;IAC5E,gCAAgC;IAChC,IAAIN,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEQ,2BAA2B,EAAE,GACnCC,QAAQ;QACV,sDAAsD;QACtD,MAAMC,2BAA2BF;QAEjCd,WAAW,CAACC;YACVe,yBAAyB;gBACvBP,YAAYT,QAAQ,CAACC,QAAQU;YAC/B;QACF;IACF,OAAO;;IAKP,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,4EAA4E;IAC5E,yBAAyB;IACzB,MAAMM,qBAAqBC,CAAAA,GAAAA,OAAAA,OAAO,EAAC;QACjC,IAAI,CAACf,SAAS;;QAId,IAAIgB,CAAAA,GAAAA,YAAAA,UAAU,EAACT,QAAQ;YACrB,8EAA8E;YAC9E,kFAAkF;YAClF,IAAIU,uBAAuBb,sBAAsBc,GAAG,CAACX;YACrD,IAAIU,yBAAyBE,WAAW;gBACtC,MAAMC,YAA4B,EAAE;gBACpCH,uBAAuBI,QAAQC,OAAO,CAACf,OAAOgB,IAAI,CAAC,CAACC;oBAClD,IAAIA,WAAWJ,SAAS,KAAK,MAAM;wBACjCA,UAAUK,IAAI,IAAID,WAAWJ,SAAS;oBACxC;oBACA,OAAOI;gBACT;gBACAP,qBAAqBS,UAAU,GAAGN;gBAElChB,sBAAsBuB,GAAG,CAACpB,OAAOU;YACnC;YAEA,OAAOA;QACT;QACA,OAAOV;IACT,GAAG;QAACA;KAAM;IAEV,OAAOS,CAAAA,GAAAA,YAAAA,UAAU,EAACF,sBACdc,CAAAA,GAAAA,OAAAA,GAAG,EAACd,sBACJA;AACN","ignoreList":[0]}},
    {"offset": {"line": 1473, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-call-server.ts"],"sourcesContent":["import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n"],"names":["callServer","actionId","actionArgs","Promise","resolve","reject","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_ACTION"],"mappings":";;;+BAIsBA,cAAAA;;;eAAAA;;;uBAJU;oCACK;gCACG;AAEjC,eAAeA,WAAWC,QAAgB,EAAEC,UAAiB;IAClE,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3BC,CAAAA,GAAAA,OAAAA,eAAe,EAAC;YACdC,CAAAA,GAAAA,gBAAAA,uBAAuB,EAAC;gBACtBC,MAAMC,oBAAAA,oBAAoB;gBAC1BR;gBACAC;gBACAE;gBACAC;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1509, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-find-source-map-url.ts"],"sourcesContent":["const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n"],"names":["findSourceMapURL","basePath","process","env","__NEXT_ROUTER_BASEPATH","pathname","NODE_ENV","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined"],"mappings":"AAAiBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAGtCJ,oBAAAA;;;eAAAA;;;AAHb,MAAMC,mDAAiD;AACvD,MAAMI,WAAW,GAAGJ,SAAS,oBAAoB,CAAC;AAE3C,MAAMD,mBACXE,QAAQC,GAAG,CAACG,QAAQ,KAAK,cACrB,SAASN,iBAAiBO,QAAgB;IACxC,IAAIA,aAAa,IAAI;QACnB,OAAO;IACT;IAEA,IACEA,SAASC,UAAU,CAACC,SAASC,QAAQ,CAACC,MAAM,KAC5CJ,SAASK,QAAQ,CAAC,kBAClB;QACA,kEAAkE;QAClE,mEAAmE;QACnE,qEAAqE;QACrE,mEAAmE;QACnE,qEAAqE;QACrE,4DAA4D;QAC5D,6CAA6C;QAC7C,OAAO,GAAGL,SAAS,IAAI,CAAC;IAC1B;IAEA,MAAMM,MAAM,IAAIC,IAAIT,UAAUI,SAASC,QAAQ,CAACC,MAAM;IACtDE,IAAIE,YAAY,CAACC,GAAG,CAAC,YAAYT;IAEjC,OAAOM,IAAII,IAAI;AACjB,IACAC","ignoreList":[0]}},
    {"offset": {"line": 1551, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/match-segments.ts"],"sourcesContent":["import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n"],"names":["matchSegment","existingSegment","segment"],"mappings":";;;+BAEaA,gBAAAA;;;eAAAA;;;AAAN,MAAMA,eAAe,CAC1BC,iBACAC;IAEA,oCAAoC;IACpC,IAAI,OAAOD,oBAAoB,UAAU;QACvC,IAAI,OAAOC,YAAY,UAAU;YAC/B,wCAAwC;YACxC,OAAOD,oBAAoBC;QAC7B;QACA,OAAO;IACT;IAEA,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAO;IACT;IACA,OAAOD,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE,IAAID,eAAe,CAAC,EAAE,KAAKC,OAAO,CAAC,EAAE;AAC/E","ignoreList":[0]}},
    {"offset": {"line": 1585, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","split","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1715, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n"],"names":["handleMutable","isNotUndefined","value","state","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","changedPath","computeChangedPath","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","debugInfo","collectedDebugInfo"],"mappings":";;;+BAWgBA,iBAAAA;;;eAAAA;;;oCAXmB;AAOnC,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASF,cACdG,KAA2B,EAC3BC,OAAgB;IAEhB,0DAA0D;IAC1D,MAAMC,eAAeD,QAAQC,YAAY,IAAI;IAE7C,IAAIC,kBAAkBH,MAAMG,eAAe;IAC3C,IAAIC,UAAUJ,MAAMI,OAAO;IAE3B,IAAIN,eAAeG,QAAQI,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,cAAcC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACP,MAAMQ,IAAI,EAAEP,QAAQI,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDH,kBAAkBC;YAClBA,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUJ,MAAMS,YAAY;QAC9B;IACA,0EAA0E;IAC5E;IAEA,OAAO;QACL,YAAY;QACZA,cAAcR,QAAQQ,YAAY,IAAIT,MAAMS,YAAY;QACxDC,gBAAgBT,QAAQS,cAAc,IAAIV,MAAMU,cAAc;QAC9DC,SAAS;YACPC,aAAad,eAAeG,QAAQW,WAAW,IAC3CX,QAAQW,WAAW,GACnBZ,MAAMW,OAAO,CAACC,WAAW;YAC7BC,eAAef,eAAeG,QAAQY,aAAa,IAC/CZ,QAAQY,aAAa,GACrBb,MAAMW,OAAO,CAACE,aAAa;YAC/BC,4BAA4BhB,eAC1BG,QAAQa,0BAA0B,IAEhCb,QAAQa,0BAA0B,GAClCd,MAAMW,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOd,eACHJ,eAAeG,SAASgB,sBACtB,OACAjB,MAAMe,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBjB,QAAQiB,cAAc,IAAI;YAC1CC,cAAcjB,eAEV,AACAD,QAAQkB,YAAY,IAAIlB,QAAQkB,IADI,QACQ,KAAK,KAE/CC,mBAAmBnB,QAAQkB,YAAY,CAACE,KAAK,CAAC,MAC9CrB,MAAMe,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAcpB,eACTD,SAASgB,sBAAsBjB,MAAMe,iBAAiB,CAACO,YAAY,GAEpE,EAAE;QACR;QACA,eAAe;QACfC,OAAOtB,QAAQsB,KAAK,GAAGtB,QAAQsB,KAAK,GAAGvB,MAAMuB,KAAK;QAClD,8BAA8B;QAC9Bf,MAAMV,eAAeG,QAAQI,WAAW,IACpCJ,QAAQI,WAAW,GACnBL,MAAMQ,IAAI;QACdJ;QACAD,iBAAiBA;QACjBqB,WAAWvB,QAAQwB,kBAAkB,IAAI;IAC3C;AACF","ignoreList":[0]}},
    {"offset": {"line": 1782, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n"],"names":["DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","generateSegmentsFromPatch","handleExternalUrl","navigateReducer","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","handleMutable","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","handleNavigationResult","result","tag","NavigationResultTag","MPA","newUrl","data","NoOp","newCanonicalUrl","oldUrl","URL","onlyHashChange","pathname","search","hash","shouldScroll","hashFragment","Success","cache","cacheNode","patchedTree","flightRouterState","renderedSearch","Async","then","asyncResult","action","isExternalUrl","navigateType","href","createHrefFromUrl","preserveCustomHistoryState","toString","document","getElementById","currentUrl","location","origin","navigateUsingSegmentCache","tree","nextUrl"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1961, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/route-params.ts"],"sourcesContent":["import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n"],"names":["doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","get","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathname","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","prefix","i","segment","ROOT_SEGMENT_REQUEST_KEY","startsWith","PAGE_SEGMENT_KEY","endsWith","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","Object","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","process","env","NODE_ENV","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","split","result","key","value","entries","undefined","Array","isArray","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2189, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/flight-data-helpers.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n"],"names":["createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","response","fallbackInitialRSCPayload","renderedPathname","getRenderedPathname","renderedSearch","getRenderedSearch","canonicalUrl","createHrefFromUrl","URL","location","href","originalFlightDataPath","f","originalFlightRouterState","b","c","split","q","i","fillInFallbackFlightRouterState","m","G","S","flightRouterState","pathnameParts","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","doesStaticSegmentAppearInURL","paramName","paramType","paramValue","parseDynamicParamFromURLPart","cacheKey","getCacheKeyForDynamicParam","childPathnamePartsIndex","children","newChildren","key","childFlightRouterState","newState","flightSegmentPath","flightData","map","isHmrRefresh","encodeURIComponent","JSON","stringify","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","Object","entries","result","shouldPreserveRefreshMarker","undefined","startsWith","PAGE_SEGMENT_KEY","Boolean"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY"],"mappings":";;;+BAGgBA,wBAAAA;;;eAAAA;;;yBAFiB;AAE1B,SAASA,qBACdC,OAAgB,EAChBC,0BAAmC,KAAK;IAExC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAO,GAAGA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEA,OAAO,CAAC,EAAE,EAAE;IACpD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,SAAAA,gBAAgB,GAAG;QACnE,OAAOA,SAAAA,gBAAgB;IACzB;IAEA,OAAOL;AACT","ignoreList":[0]}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\nexport function fillLazyItemsTillLeafWithHead(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n        ? cacheNodeSeedData[1][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[0]\n          const loading = parallelSeedData[2]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior  no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            navigatedAt,\n          }\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n            navigatedAt,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          navigatedAt,\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[0]\n      const loading = parallelSeedData[2]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head\n    )\n  }\n}\n"],"names":["fillLazyItemsTillLeafWithHead","navigatedAt","newCache","existingCache","routerState","cacheNodeSeedData","head","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","createRouterCacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","set","existingParallelRoutes"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2577, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/invalidate-cache-by-router-state.ts"],"sourcesContent":["import type {\n  CacheNode,\n  FlightRouterState,\n} from '../../../shared/lib/app-router-types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n"],"names":["invalidateCacheByRouterState","newCache","existingCache","routerState","key","segmentForParallelRoute","cacheKey","createRouterCacheKey","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","delete","set"],"mappings":";;;+BASgBA,gCAAAA;;;eAAAA;;;sCALqB;AAK9B,SAASA,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACF;QACtC,MAAMG,kCACJN,cAAcO,cAAc,CAACC,GAAG,CAACN;QACnC,IAAII,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACP;YAC9BL,SAASQ,cAAc,CAACK,GAAG,CAACV,KAAKO;QACnC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2611, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode, Segment } from '../../../shared/lib/app-router-types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const rsc = cacheNodeSeedData[0]\n        const loading = cacheNodeSeedData[2]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc: fillLazyItems || segment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n          navigatedAt,\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, true)\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData\n): void {\n  fillCacheHelper(navigatedAt, newCache, existingCache, flightData, false)\n}\n"],"names":["fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading","fillCacheHelper","navigatedAt","newCache","existingCache","flightData","fillLazyItems","segmentPath","seedData","cacheNodeSeedData","tree","treePatch","head","newCacheNode","existingCacheNode","i","length","parallelRouteKey","segment","isLastEntry","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","loading","PAGE_SEGMENT_KEY","prefetchRsc","prefetchHead","invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2723, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  navigatedAt: number,\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[0]\n    const loading = seedData[2]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior  no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(navigatedAt, cache, existingCache, flightData)\n  }\n\n  return true\n}\n"],"names":["applyFlightData","navigatedAt","existingCache","cache","flightData","tree","treePatch","seedData","head","isRootRender","rsc","loading","prefetchRsc","fillLazyItemsTillLeafWithHead","parallelRoutes","Map","fillCacheWithNewSubTreeData"],"mappings":";;;+BAKgBA,mBAAAA;;;eAAAA;;;+CAJ8B;6CACF;AAGrC,SAASA,gBACdC,WAAmB,EACnBC,aAAwB,EACxBC,KAAgB,EAChBC,UAAgC;IAEhC,0DAA0D;IAC1D,MAAM,EAAEC,MAAMC,SAAS,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE,GAAGL;IAE1D,8FAA8F;IAC9F,IAAIG,aAAa,MAAM;QACrB,OAAO;IACT;IAEA,IAAIE,cAAc;QAChB,MAAMC,MAAMH,QAAQ,CAAC,EAAE;QACvB,MAAMI,UAAUJ,QAAQ,CAAC,EAAE;QAC3BJ,MAAMQ,OAAO,GAAGA;QAChBR,MAAMO,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BP,MAAMS,WAAW,GAAG;QACpBC,CAAAA,GAAAA,+BAAAA,6BAA6B,EAC3BZ,aACAE,OACAD,eACAI,WACAC,UACAC;IAEJ,OAAO;QACL,2CAA2C;QAC3CL,MAAMO,GAAG,GAAGR,cAAcQ,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BP,MAAMS,WAAW,GAAGV,cAAcU,WAAW;QAC7CT,MAAMW,cAAc,GAAG,IAAIC,IAAIb,cAAcY,cAAc;QAC3DX,MAAMQ,OAAO,GAAGT,cAAcS,OAAO;QACrC,4DAA4D;QAC5DK,CAAAA,GAAAA,6BAAAA,2BAA2B,EAACf,aAAaE,OAAOD,eAAeE;IACjE;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2778, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-build-id.ts"],"sourcesContent":["// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n"],"names":["getAppBuildId","setAppBuildId","globalBuildId","buildId"],"mappings":"AAAA,4EAA4E;AAC5E,4EAA4E;AAC5E,wDAAwD;AACxD,EAAE;AACF,+EAA+E;AAC/E,4EAA4E;AAC5E,sCAAsC;AAEtC,0EAA0E;AAC1E,sEAAsE;AACtE,6EAA6E;AAC7E,yEAAyE;AACzE,6EAA6E;;;;;;;;;;;;;;;IAO7DA,aAAa,EAAA;eAAbA;;IAJAC,aAAa,EAAA;eAAbA;;;AAFhB,IAAIC,gBAAwB;AAErB,SAASD,cAAcE,OAAe;IAC3CD,gBAAgBC;AAClB;AAEO,SAASH;IACd,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 2829, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","uniqueCacheKey","computeCacheBustingSearchParam","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","rawQuery","startsWith","slice","pairs","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join"],"mappings":";;;;;;;;;;;;;;IA4BaA,0BAA0B,EAAA;eAA1BA;;IA6BAC,kCAAkC,EAAA;eAAlCA;;;yCAvDkC;kCAOxC;AAmBA,MAAMD,6BAA6B,CACxCE,KACAC;IAEA,MAAMC,iBAAiBC,CAAAA,GAAAA,yBAAAA,8BAA8B,EACnDF,OAAO,CAACG,kBAAAA,2BAA2B,CAAC,EACpCH,OAAO,CAACI,kBAAAA,mCAAmC,CAAC,EAC5CJ,OAAO,CAACK,kBAAAA,6BAA6B,CAAC,EACtCL,OAAO,CAACM,kBAAAA,QAAQ,CAAC;IAEnBR,mCAAmCC,KAAKE;AAC1C;AAkBO,MAAMH,qCAAqC,CAChDC,KACAQ;IAEA;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBT,IAAIU,MAAM;IACjC,MAAMC,WAAWF,eAAeG,UAAU,CAAC,OACvCH,eAAeI,KAAK,CAAC,KACrBJ;IAEJ,+EAA+E;IAC/E,6DAA6D;IAC7D,MAAMK,QAAQH,SACXI,KAAK,CAAC,KACNC,MAAM,CAAC,CAACC,OAASA,QAAQ,CAACA,KAAKL,UAAU,CAAC,GAAGM,kBAAAA,oBAAoB,CAAC,CAAC,CAAC;IAEvE,IAAIV,KAAKW,MAAM,GAAG,GAAG;QACnBL,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,CAAC,CAAC,EAAEV,MAAM;IAC9C,OAAO;QACLM,MAAMM,IAAI,CAAC,GAAGF,kBAAAA,oBAAoB,EAAE;IACtC;IACAlB,IAAIU,MAAM,GAAGI,MAAMK,MAAM,GAAG,CAAC,CAAC,EAAEL,MAAMO,IAAI,CAAC,MAAM,GAAG;AACtD","ignoreList":[0]}},
    {"offset": {"line": 2890, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      fetchPriority,\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","doMpaNavigation","url","urlToUrlWithoutFlightMarker","URL","location","origin","toString","isPageUnloading","window","addEventListener","options","flightRouterState","nextUrl","prefetchKind","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","PrefetchKind","AUTO","NEXT_ROUTER_PREFETCH_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_URL","originalUrl","fetchPriority","TEMPORARY","__NEXT_CONFIG_OUTPUT","pathname","endsWith","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","responseUrl","canonicalUrl","redirected","contentType","get","interception","includes","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","getAppBuildId","b","normalizedFlightData","normalizeFlightData","f","flightData","renderedSearch","getRenderedSearch","couldBeIntercepted","prerendered","S","debugInfo","_debugInfo","err","console","error","signal","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","undefined","fetchUrl","setCacheBustingSearchParam","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","searchParams","NEXT_RSC_UNION_QUERY","delete","rscResponse","href","status","requestHeaders","callServer","findSourceMapURL","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"AAsDEQ,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBACzBF,QAAQC,GAAG,CAACE,0BAA0B,EACtC;AAxDF;;;;;;;;;;;;;;;;;IA4TsBX,WAAW,EAAA;eAAXA;;IA2JNC,4BAA4B,EAAA;eAA5BA;;IA1VMC,mBAAmB,EAAA;eAAnBA;;;wBAtHf;kCAoBA;+BACoB;qCACM;oCACJ;mCAKtB;4BACuB;4CACa;6BAIpC;AAGP,MAAMC,2BACJC,QAAAA,wBAA+B;AACjC,MAAMC,kBACJC,QAAAA,eAAsB;AAExB,IAAIC;AAIJ;;AA+CA,SAASM,gBAAgBC,GAAW;IAClC,OAAOC,CAAAA,GAAAA,aAAAA,2BAA2B,EAAC,IAAIC,IAAIF,KAAKG,SAASC,MAAM,GAAGC,QAAQ;AAC5E;AAEA,IAAIC,kBAAkB;AAEtB,IAAI,OAAOC,WAAW,aAAa;IACjC,sEAAsE;IACtE,6EAA6E;IAC7E,6DAA6D;IAC7DA,OAAOC,gBAAgB,CAAC,YAAY;QAClCF,kBAAkB;IACpB;IAEA,2EAA2E;IAC3E,gDAAgD;IAChDC,OAAOC,gBAAgB,CAAC,YAAY;QAClCF,kBAAkB;IACpB;AACF;AAMO,eAAelB,oBACpBY,GAAQ,EACRS,OAAmC;IAEnC,MAAM,EAAEC,iBAAiB,EAAEC,OAAO,EAAEC,YAAY,EAAE,GAAGH;IAErD,MAAMI,UAA0B;QAC9B,yBAAyB;QACzB,CAACC,kBAAAA,UAAU,CAAC,EAAE;QACd,mCAAmC;QACnC,CAACC,kBAAAA,6BAA6B,CAAC,EAAEC,CAAAA,GAAAA,mBAAAA,kCAAkC,EACjEN,mBACAD,QAAQQ,YAAY;IAExB;IAEA;;;;;GAKC,GACD,IAAIL,iBAAiBM,oBAAAA,YAAY,CAACC,IAAI,EAAE;QACtCN,OAAO,CAACO,kBAAAA,2BAA2B,CAAC,GAAG;IACzC;IAEA,IAAI1B,QAAQC,GAAG,CAACC,QAAQ,gCAAK,iBAAiBa,QAAQQ,YAAY,EAAE;QAClEJ,OAAO,CAACQ,kBAAAA,uBAAuB,CAAC,GAAG;IACrC;IAEA,IAAIV,SAAS;QACXE,OAAO,CAACS,kBAAAA,QAAQ,CAAC,GAAGX;IACtB;IAEA,6EAA6E;IAC7E,oFAAoF;IACpF,MAAMY,cAAcvB;IAEpB,IAAI;QACF,wHAAwH;QACxH,4HAA4H;QAC5H,kEAAkE;QAClE,yHAAyH;QACzH,MAAMwB,gBAAgBZ,eAClBA,iBAAiBM,oBAAAA,YAAY,CAACO,SAAS,GACrC,SACA,QACF;QAEJ,IAAI/B,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;;QAc3C,wEAAwE;QACxE,0DAA0D;QAC1D,2DAA2D;QAC3D,MAAMiC,cACJnC,QAAQC,GAAG,CAACmC,UAAU,qBAAI,CAACpC,QAAQC,GAAG,CAACoC,uBAAuB;QAChE,MAAMC,0BAA0B,CAACH;QACjC,MAAMI,MAAM,MAAM/C,YAChBc,KACAa,SACAW,eACAQ;QAGF,MAAME,cAAcjC,CAAAA,GAAAA,aAAAA,2BAA2B,EAAC,IAAIC,IAAI+B,IAAIjC,GAAG;QAC/D,MAAMmC,eAAeF,IAAIG,UAAU,GAAGF,cAAcX;QAEpD,MAAMc,cAAcJ,IAAIpB,OAAO,CAACyB,GAAG,CAAC,mBAAmB;QACvD,MAAMC,eAAe,CAAC,CAACN,IAAIpB,OAAO,CAACyB,GAAG,CAAC,SAASE,SAASlB,kBAAAA,QAAQ;QACjE,MAAMmB,YAAY,CAAC,CAACR,IAAIpB,OAAO,CAACyB,GAAG,CAACI,kBAAAA,wBAAwB;QAC5D,MAAMC,yBAAyBV,IAAIpB,OAAO,CAACyB,GAAG,CAC5CM,kBAAAA,6BAA6B;QAE/B,MAAMC,YACJF,2BAA2B,OACvBG,SAASH,wBAAwB,MAAM,OACvC,CAAC;QACP,IAAII,mBAAmBV,YAAYW,UAAU,CAACC,kBAAAA,uBAAuB;QAErE,IAAIvD,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;;QAQ3C,4FAA4F;QAC5F,oEAAoE;QACpE,IAAI,CAACmD,oBAAoB,CAACd,IAAIiB,EAAE,IAAI,CAACjB,IAAIkB,IAAI,EAAE;YAC7C,2FAA2F;YAC3F,IAAInD,IAAIoD,IAAI,EAAE;gBACZlB,YAAYkB,IAAI,GAAGpD,IAAIoD,IAAI;YAC7B;YAEA,OAAOrD,gBAAgBmC,YAAY7B,QAAQ;QAC7C;QAEA,uEAAuE;QACvE,0DAA0D;QAC1D,wDAAwD;QACxD,oGAAoG;QACpG,mDAAmD;QACnD,2EAA2E;QAC3E,qBAAqB;QACrB,IAAIX,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,CAACF,QAAQC,GAAG,CAAC0D,SAAS,EAAE;;QAMrE,IAAIE,wBAAwBtB,IAAIuB,cAAc;QAC9C,IAAID,0BAA0B,MAAM;YAClC,mEAAmE;YACnE,mEAAmE;YACnE,yEAAyE;YACzE,gEAAgE;YAChE,cAAc;YACd,MAAME,eAAehB,YACjBiB,8BAA8BzB,IAAIkB,IAAI,IACtClB,IAAIkB,IAAI;YACZI,wBACEpE,6BACEsE,cACA5C;QAEN;QAEA,MAAM2C,iBAAiB,MAAMD;QAE7B,IAAII,CAAAA,GAAAA,YAAAA,aAAa,QAAOH,eAAeI,CAAC,EAAE;YACxC,OAAO7D,gBAAgBkC,IAAIjC,GAAG;QAChC;QAEA,MAAM6D,uBAAuBC,CAAAA,GAAAA,mBAAAA,mBAAmB,EAACN,eAAeO,CAAC;QACjE,IAAI,OAAOF,yBAAyB,UAAU;YAC5C,OAAO9D,gBAAgB8D;QACzB;QAEA,OAAO;YACLG,YAAYH;YACZ1B,cAAcA;YACd8B,gBAAgBC,CAAAA,GAAAA,aAAAA,iBAAiB,EAACjC;YAClCkC,oBAAoB5B;YACpB6B,aAAaZ,eAAea,CAAC;YAC7B5B;YACAI;YACAyB,WAAWf,sBAAsBgB,UAAU,IAAI;QACjD;IACF,EAAE,OAAOC,KAAK;QACZ,IAAI,CAAClE,iBAAiB;YACpBmE,QAAQC,KAAK,CACX,CAAC,gCAAgC,EAAEnD,YAAY,qCAAqC,CAAC,EACrFiD;QAEJ;QAEA,iDAAiD;QACjD,qHAAqH;QACrH,iGAAiG;QACjG,OAAOjD,YAAYlB,QAAQ;IAC7B;AACF;AAiBO,eAAenB,YACpBc,GAAQ,EACRa,OAAuB,EACvBW,aAA6C,EAC7CQ,uBAAgC,EAChC2C,MAAoB;IAEpB,6EAA6E;IAC7E,0DAA0D;IAC1D,uBAAuB;IAEvB,IAAIjF,QAAQC,GAAG,CAACiF,gBAAgB,IAAIpD,kBAAkB,MAAM;;IAI5D,IAAI9B,QAAQC,GAAG,CAACkF,kBAAkB,EAAE;;IAIpC,IAAInF,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,IAAIkF,KAAKC,QAAQ,EAAE;YACjBlE,OAAO,CAACmE,kBAAAA,2BAA2B,CAAC,GAAGF,KAAKC,QAAQ;QACtD;QAEA,yEAAyE;QACzE,wEAAwE;QACxE,yEAAyE;QACzElE,OAAO,CAACoE,kBAAAA,sBAAsB,CAAC,GAAGC,OAC/BC,eAAe,CAAC,IAAIC,YAAY,GAAG,CAAC,EAAE,CACtC/E,QAAQ,CAAC;IACd;IAEA,MAAMgF,eAA4B;QAChC,wFAAwF;QACxFC,aAAa;QACbzE;QACA0E,UAAU/D,iBAAiBgE;QAC3Bb;IACF;IACA,6EAA6E;IAC7E,2EAA2E;IAC3E,yBAAyB;IACzB,IAAIc,WAAW,IAAIvF,IAAIF;IACvB0F,CAAAA,GAAAA,4BAAAA,0BAA0B,EAACD,UAAU5E;IACrC,IAAI8E,eAAeC,MAAMH,UAAUJ;IACnC,4EAA4E;IAC5E,8EAA8E;IAC9E,0DAA0D;IAC1D,EAAE;IACF,6EAA6E;IAC7E,0DAA0D;IAC1D,0EAA0E;IAC1E,yEAAyE;IACzE,6EAA6E;IAC7E,oCAAoC;IACpC,IAAI9B,wBAAwBvB,0BACxB6D,oBAAuBF,cAAc9E,WACrC;IACJ,IAAIiF,kBAAkB,MAAMH;IAE5B,wEAAwE;IACxE,sEAAsE;IACtE,wEAAwE;IACxE,0EAA0E;IAC1E,6EAA6E;IAC7E,cAAc;IACd,EAAE;IACF,8EAA8E;IAC9E,6EAA6E;IAC7E,mCAAmC;IACnC,EAAE;IACF,yEAAyE;IACzE,8EAA8E;IAC9E,cAAc;IACd,EAAE;IACF,0EAA0E;IAC1E,8EAA8E;IAC9E,EAAE;IACF,wEAAwE;IACxE,0EAA0E;IAC1E,gDAAgD;IAEhD,IAAIvD,aAAa0D,gBAAgB1D,UAAU;IAC3C,IAAI1C,QAAQC,GAAG,CAACoG,0CAA0C,EAAE;;IAyC5D,6EAA6E;IAC7E,yCAAyC;IACzC,MAAM7D,cAAc,IAAIhC,IAAI4F,gBAAgB9F,GAAG,EAAEyF;IACjDvD,YAAYgE,YAAY,CAACE,MAAM,CAACD,kBAAAA,oBAAoB;IAEpD,MAAME,cAA8B;QAClCrG,KAAKkC,YAAYoE,IAAI;QAErB,sEAAsE;QACtE,qDAAqD;QACrD,wEAAwE;QACxE,oEAAoE;QACpElE;QAEA,qEAAqE;QACrE,wEAAwE;QACxE,6BAA6B;QAC7Bc,IAAI4C,gBAAgB5C,EAAE;QACtBrC,SAASiF,gBAAgBjF,OAAO;QAChCsC,MAAM2C,gBAAgB3C,IAAI;QAC1BoD,QAAQT,gBAAgBS,MAAM;QAE9B,uEAAuE;QACvE,0EAA0E;QAC1E,+BAA+B;QAC/B/C,gBAAgBD;IAClB;IAEA,OAAO8C;AACT;AAEO,SAASlH,6BACdsE,YAAwC,EACxC+C,cAA8B;IAE9B,OAAOnH,yBAAyBoE,cAAc;QAC5CgD,YAAAA,eAAAA,UAAU;QACVC,kBAAAA,qBAAAA,gBAAgB;QAChBC,cAAclH,sBAAsBA,mBAAmB+G;IACzD;AACF;AAEA,SAASX,oBACPe,kBAAqC,EACrCJ,cAA8B;IAE9B,OAAOjH,gBAAgBqH,oBAAoB;QACzCH,YAAAA,eAAAA,UAAU;QACVC,kBAAAA,qBAAAA,gBAAgB;QAChBC,cAAclH,sBAAsBA,mBAAmB+G;IACzD;AACF;AAEA,SAAS9C,8BACPmD,oBAAgD;IAEhD,0EAA0E;IAC1E,4EAA4E;IAC5E,uEAAuE;IACvE,0EAA0E;IAC1E,8DAA8D;IAC9D,2CAA2C;IAC3C,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8EAA8E;IAC9E,+BAA+B;IAC/B,MAAMC,SAASD,qBAAqBE,SAAS;IAC7C,OAAO,IAAIC,eAAe;QACxB,MAAMC,MAAKC,UAAU;YACnB,MAAO,KAAM;gBACX,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE,GAAG,MAAMN,OAAOO,IAAI;gBACzC,IAAI,CAACF,MAAM;oBACT,mEAAmE;oBACnE,mBAAmB;oBACnBD,WAAWI,OAAO,CAACF;oBACnB;gBACF;gBACA,qEAAqE;gBACrE,qBAAqB;gBACrB;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3200, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then((result) => {\n      if (typeof result !== 'string') {\n        const { flightData } = result\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When result is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n"],"names":["addRefreshMarkerToActiveParallelSegments","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","navigatedAt","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","fetchServerResponse","URL","location","origin","flightRouterState","nextUrl","then","result","flightData","flightDataPath","applyFlightData","push","key","parallelFetchPromise","Promise","all","tree","path","segment","includes","PAGE_SEGMENT_KEY"],"mappings":";;;;;;;;;;;;;;IA4HgBA,wCAAwC,EAAA;eAAxCA;;IA/FMC,+BAA+B,EAAA;eAA/BA;;;iCAxBU;qCACI;yBACH;AAsB1B,eAAeA,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,EACjDG,WAAW,EACXC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb;IACC,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,eAAeC,CAAAA,GAAAA,qBAAAA,mBAAmB,EACtC,IAAIC,IAAIP,aAAaQ,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAAClB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEmB,SAASd,iBAAiBF,MAAMgB,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC,CAACC;YACN,IAAI,OAAOA,WAAW,UAAU;gBAC9B,MAAM,EAAEC,UAAU,EAAE,GAAGD;gBACvB,KAAK,MAAME,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5EE,CAAAA,GAAAA,iBAAAA,eAAe,EACbtB,aACAE,cACAA,cACAmB;gBAEJ;YACF,OAAO;YACL,wGAAwG;YACxG,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAb,cAAce,IAAI,CAACZ;IACrB;IAEA,IAAK,MAAMa,OAAOnB,eAAgB;QAChC,MAAMoB,uBAAuB5B,oCAAoC;YAC/DG;YACAC;YACAF,aAAaM,cAAc,CAACmB,IAAI;YAChCtB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAce,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAACnB;AACpB;AAQO,SAAShB,yCACdoC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASzB,kBAAkBE,cAAc,GAAGqB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACC,SAAAA,gBAAgB,KAAKzB,kBAAkB,WAAW;QACrEqB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAMJ,OAAOnB,eAAgB;QAChCb,yCAAyCa,cAAc,CAACmB,IAAI,EAAEK;IAChE;AACF","ignoreList":[0]}},
    {"offset": {"line": 3306, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["applyRouterStatePatchToTree","applyPatch","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","DEFAULT_SEGMENT_KEY","matchSegment","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","flightSegmentPath","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","addRefreshMarkerToActiveParallelSegments","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch","getNextFlightSegmentPath"],"mappings":";;;+BA6EgBA,+BAAAA;;;eAAAA;;;yBAzEoB;mCACK;+BACZ;iDAC4B;AAEzD;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBE,SAAAA,mBAAmB,IACpCJ,mBAAmBI,SAAAA,mBAAmB,EACtC;QACA,OAAON;IACT;IAEA,IAAIO,CAAAA,GAAAA,eAAAA,YAAY,EAACL,gBAAgBE,eAAe;QAC9C,MAAMI,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAON,sBAAuB;YACvC,MAAMO,8BACJ,OAAOL,mBAAmB,CAACI,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGV,WACvBI,qBAAqB,CAACM,IAAI,EAC1BJ,mBAAmB,CAACI,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGN,qBAAqB,CAACM,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOJ,oBAAqB;YACrC,IAAIG,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGJ,mBAAmB,CAACI,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACT;YAAgBM;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIR,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOW;IACT;IAEA,OAAOV;AACT;AAOO,SAASH,4BACdc,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0BZ,WAAWc,mBAAmBC;QAE9DQ,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACX,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGZ;IAE3C,iGAAiG;IACjG,IAAI,CAACL,CAAAA,GAAAA,eAAAA,YAAY,EAACgB,gBAAgBP,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMS,cAAcb,kBAAkBS,MAAM,KAAK;IAEjD,IAAIK;IACJ,IAAID,aAAa;QACfC,qBAAqB3B,WAAWkB,cAAc,CAACO,iBAAiB,EAAEV;IACpE,OAAO;QACLY,qBAAqB5B,4BACnB6B,CAAAA,GAAAA,mBAAAA,wBAAwB,EAACf,oBACzBK,cAAc,CAACO,iBAAiB,EAChCV,WACAC;QAGF,IAAIW,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BC,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACO,iBAAiB,EAAEE;QACtB;QACAR;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAW,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACX,MAAMI;IAE/C,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 3413, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;+BAEgBA,+BAAAA;;;eAAAA;;;AAAT,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD","ignoreList":[0]}},
    {"offset": {"line": 3466, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/app-router-announcer.tsx"],"sourcesContent":["import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../shared/lib/app-router-types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n"],"names":["AppRouterAnnouncer","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","tree","portalNode","setPortalNode","useState","useEffect","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal"],"mappings":";;;+BA6BgBA,sBAAAA;;;eAAAA;;;uBA7B4B;0BACf;AAG7B,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;IACP,MAAMC,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,mBAAmBG,YAAYC,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEO,SAASb,mBAAmB,EAAEsB,IAAI,EAA+B;IACtE,MAAM,CAACC,YAAYC,cAAc,GAAGC,CAAAA,GAAAA,OAAAA,QAAQ,EAAqB;IAEjEC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,MAAMb,YAAYV;QAClBqB,cAAcX;QACd,OAAO;YACL,MAAMJ,YAAYJ,SAASsB,oBAAoB,CAAC1B,eAAe,CAAC,EAAE;YAClE,IAAIQ,WAAWmB,aAAa;gBAC1BvB,SAASgB,IAAI,CAACQ,WAAW,CAACpB;YAC5B;QACF;IACF,GAAG,EAAE;IAEL,MAAM,CAACqB,mBAAmBC,qBAAqB,GAAGN,CAAAA,GAAAA,OAAAA,QAAQ,EAAC;IAC3D,MAAMO,gBAAgBC,CAAAA,GAAAA,OAAAA,MAAM,EAAqBC;IAEjDR,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACR,IAAIS,eAAe;QACnB,IAAI9B,SAAS+B,KAAK,EAAE;YAClBD,eAAe9B,SAAS+B,KAAK;QAC/B,OAAO;YACL,MAAMC,aAAahC,SAASiC,aAAa,CAAC;YAC1C,IAAID,YAAY;gBACdF,eAAeE,WAAWE,SAAS,IAAIF,WAAWG,WAAW,IAAI;YACnE;QACF;QAEA,4EAA4E;QAC5E,iCAAiC;QACjC,IACER,cAAcS,OAAO,KAAKP,aAC1BF,cAAcS,OAAO,KAAKN,cAC1B;YACAJ,qBAAqBI;QACvB;QACAH,cAAcS,OAAO,GAAGN;IAC1B,GAAG;QAACb;KAAK;IAET,OAAOC,aAAAA,WAAAA,GAAamB,CAAAA,GAAAA,UAAAA,YAAY,EAACZ,mBAAmBP,cAAc;AACpE","ignoreList":[0]}},
    {"offset": {"line": 3546, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;+BAaDA,2BAAAA;;;eAAAA;;;AAZb,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMH,gCAAgCI;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 3589, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unrecognized-action-error.ts"],"sourcesContent":["export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n"],"names":["UnrecognizedActionError","unstable_isUnrecognizedActionError","Error","constructor","args","name","error"],"mappings":";;;;;;;;;;;;;;IAAaA,uBAAuB,EAAA;eAAvBA;;IAyBGC,kCAAkC,EAAA;eAAlCA;;;AAzBT,MAAMD,gCAAgCE;IAC3CC,YAAY,GAAGC,IAAyC,CAAE;QACxD,KAAK,IAAIA;QACT,IAAI,CAACC,IAAI,GAAG;IACd;AACF;AAoBO,SAASJ,mCACdK,KAAc;IAEd,OAAO,CAAC,CACNA,CAAAA,SACA,OAAOA,UAAU,YACjBA,iBAAiBN,uBAAsB;AAE3C","ignoreList":[0]}},
    {"offset": {"line": 3630, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA6EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IAvBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,cAEZC,QAAQ,iIACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAG,GAAGD,eAAAA,mBAAmB,CAAC,CAAC,EAAEN,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;IAEnBA,SAASL,oBAAoBa,YAAYC,WACrCC,eAAAA,YAAY,CAACC,IAAI,GACjBD,eAAAA,YAAY,CAACE,OAAO;IAExB,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,OAAqBU,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACW,iBAAiB;AACxE;AAUO,SAASrB,wBAAwBY,KAAc;IACpD,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAAS1B,yBAAyBa,KAAoB;IAC3D,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASzB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOa,OAAOd,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 3723, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAsBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 3775, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":"AAuBOG,QAAQC,GAAG,CAACC,mCAAmC;;;;;+BADtCL,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,oCAAkD;QACpD,MAAM,OAAA,cAEL,CAFK,IAAIM,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 3828, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unstable-rethrow.browser.ts"],"sourcesContent":["import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","Error","cause"],"mappings":";;;+BAGgBA,oBAAAA;;;eAAAA;;;8BAHoB;;;;;mCACF;AAE3B,SAASA,iBAAiBC,KAAc;IAC7C,IAAIC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAAUE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,QAAQ;QAC1D,MAAMA;IACR;IAEA,IAAIA,iBAAiBG,SAAS,WAAWH,OAAO;QAC9CD,iBAAiBC,MAAMI,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 3862, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3906, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3950, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","isPrerenderInterruptedError","Error","cause"],"mappings":";;;+BAUgBA,oBAAAA;;;eAAAA;;;uCAV+B;4BACpB;8BACS;;;;;mCACF;kCAI3B;oCAC8B;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,UAC/BO,CAAAA,GAAAA,kBAAAA,2BAA2B,EAACP,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBQ,SAAS,WAAWR,OAAO;QAC9CD,iBAAiBC,MAAMS,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 3988, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,cAEZC,QAAQ,2HACRF,gBAAgB,GAEhBE,QAAQ,4HACRF,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 4015, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAcSA,uBAAuB,EAAA;eAAvBA,yBAAAA,uBAAuB;;IALvBC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IAVLC,kCAAkC,EAAA;eAAlCA;;IAWPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;yCAbe;0BAQI;+BACf;0BACJ;2BACC;8BACG;iCACI;AAX1B,SAASD;IACd,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}},
    {"offset": {"line": 4089, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/navigation.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n"],"names":["ReadonlyURLSearchParams","RedirectType","ServerInsertedHTMLContext","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","useDynamicRouteParams","window","require","undefined","useDynamicSearchParams","searchParams","useContext","SearchParamsContext","readonlySearchParams","useMemo","process","env","NODE_ENV","React","navigationPromises","use","NavigationPromisesContext","pathname","PathnameContext","router","AppRouterContext","Error","params","PathParamsContext","parallelRouteKey","context","LayoutRouterContext","promise","selectedLayoutSegmentsPromises","get","getSelectedLayoutSegmentPath","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","computeSelectedLayoutSegment"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4290, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/redirect-boundary.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      if ('handled' in error) {\n        // The redirect was already handled. We'll still catch the redirect error\n        // so that we can remount the subtree, but we don't actually need to trigger the\n        // router.push.\n        return { redirect: null, redirectType: null }\n      }\n\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n"],"names":["RedirectBoundary","RedirectErrorBoundary","HandleRedirect","redirect","reset","redirectType","router","useRouter","useEffect","React","startTransition","RedirectType","push","replace","Component","constructor","props","state","getDerivedStateFromError","error","isRedirectError","url","getURLFromRedirectError","getRedirectTypeFromError","render","setState","children"],"mappings":";;;;;;;;;;;;;;IAgFgBA,gBAAgB,EAAA;eAAhBA;;IA3CHC,qBAAqB,EAAA;eAArBA;;;;;iEApCoB;4BAEP;0BACwC;+BACpB;AAO9C,SAASC,eAAe,EACtBC,QAAQ,EACRC,KAAK,EACLC,YAAY,EAKb;IACC,MAAMC,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IAExBC,CAAAA,GAAAA,OAAAA,SAAS,EAAC;QACRC,OAAAA,OAAK,CAACC,eAAe,CAAC;YACpB,IAAIL,iBAAiBM,eAAAA,YAAY,CAACC,IAAI,EAAE;gBACtCN,OAAOM,IAAI,CAACT,UAAU,CAAC;YACzB,OAAO;gBACLG,OAAOO,OAAO,CAACV,UAAU,CAAC;YAC5B;YACAC;QACF;IACF,GAAG;QAACD;QAAUE;QAAcD;QAAOE;KAAO;IAE1C,OAAO;AACT;AAEO,MAAML,8BAA8BQ,OAAAA,OAAK,CAACK,SAAS;IAIxDC,YAAYC,KAA4B,CAAE;QACxC,KAAK,CAACA;QACN,IAAI,CAACC,KAAK,GAAG;YAAEd,UAAU;YAAME,cAAc;QAAK;IACpD;IAEA,OAAOa,yBAAyBC,KAAU,EAAE;QAC1C,IAAIC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,QAAQ;YAC1B,MAAME,MAAMC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACH;YACpC,MAAMd,eAAekB,CAAAA,GAAAA,UAAAA,wBAAwB,EAACJ;YAC9C,IAAI,aAAaA,OAAO;gBACtB,yEAAyE;gBACzE,gFAAgF;gBAChF,eAAe;gBACf,OAAO;oBAAEhB,UAAU;oBAAME,cAAc;gBAAK;YAC9C;YAEA,OAAO;gBAAEF,UAAUkB;gBAAKhB;YAAa;QACvC;QACA,wCAAwC;QACxC,MAAMc;IACR;IAEA,yIAAyI;IACzIK,SAA0B;QACxB,MAAM,EAAErB,QAAQ,EAAEE,YAAY,EAAE,GAAG,IAAI,CAACY,KAAK;QAC7C,IAAId,aAAa,QAAQE,iBAAiB,MAAM;YAC9C,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACH,gBAAAA;gBACCC,UAAUA;gBACVE,cAAcA;gBACdD,OAAO,IAAM,IAAI,CAACqB,QAAQ,CAAC;wBAAEtB,UAAU;oBAAK;;QAGlD;QAEA,OAAO,IAAI,CAACa,KAAK,CAACU,QAAQ;IAC5B;AACF;AAEO,SAAS1B,iBAAiB,EAAE0B,QAAQ,EAAiC;IAC1E,MAAMpB,SAASC,CAAAA,GAAAA,YAAAA,SAAS;IACxB,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACN,uBAAAA;QAAsBK,QAAQA;kBAASoB;;AAE5C","ignoreList":[0]}},
    {"offset": {"line": 4398, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  CacheNode,\n} from '../../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item"],"mappings":";;;+BAOgBA,mBAAAA;;;eAAAA;;;yBAHoB;sCACC;AAE9B,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB,IAAI;AACxD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB,EACjBC,4BAAoC;IAEpC,MAAMC,aAAaC,OAAOC,IAAI,CAACN,gBAAgBO,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACL;YAAOG;YAAWC;SAA6B;IACzD;IAEA,uDAAuD;IACvD,+EAA+E;IAC/E,MAAMK,qBAAqBH,OAAOC,IAAI,CAACN,gBAAgBS,MAAM,CAC3D,CAACC,MAAQA,QAAQ;IAGnB,kEAAkE;IAClE,IAAI,cAAcV,gBAAgB;QAChCQ,mBAAmBG,OAAO,CAAC;IAC7B;IAEA,KAAK,MAAMD,OAAOF,mBAAoB;QACpC,MAAM,CAACI,SAASC,oBAAoB,GAAGb,cAAc,CAACU,IAAI;QAC1D,gEAAgE;QAChE,mCAAmC;QACnC,IAAIE,YAAYE,SAAAA,mBAAmB,EAAE;YACnC;QACF;QACA,MAAMC,kBAAkBhB,MAAMC,cAAc,CAACgB,GAAG,CAACN;QACjD,IAAI,CAACK,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWC,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN;QACtC,MAAMO,8BAA8BD,CAAAA,GAAAA,sBAAAA,oBAAoB,EAACN,SAAS;QAElE,MAAMQ,YAAYL,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACG,WAAW;YACd;QACF;QAEA,MAAMC,OAAOpB,oBACXmB,WACAP,qBACAX,YAAY,MAAMe,UAClBf,YAAY,MAAMiB;QAGpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 4464, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/unresolved-thenable.ts"],"sourcesContent":["/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n"],"names":["unresolvedThenable","then"],"mappings":"AAAA;;CAEC;;;+BACYA,sBAAAA;;;eAAAA;;;AAAN,MAAMA,qBAAqB;IAChCC,MAAM,KAAO;AACf","ignoreList":[0]}},
    {"offset": {"line": 4489, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/has-base-path.ts"],"sourcesContent":["import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","pathHasPrefix"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BAJc;AAE9B,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY;IACtC,OAAOC,CAAAA,GAAAA,eAAAA,aAAa,EAACD,MAAMJ;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 4516, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/remove-base-path.ts"],"sourcesContent":["import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n"],"names":["removeBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","__NEXT_MANUAL_CLIENT_BASE_PATH","hasBasePath","length","slice","startsWith"],"mappings":"AAEkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,kBAAAA;;;eAAAA;;;6BAJY;AAE5B,MAAMC,mDAA6D;AAE5D,SAASD,eAAeK,IAAY;IACzC,IAAIH,QAAQC,GAAG,CAACG,8BAA8B,EAAE;;IAMhD,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOH;IAElCA,OAAOA,KAAKI,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACH,KAAKK,UAAU,CAAC,MAAML,OAAO,CAAC,CAAC,EAAEA,MAAM;IAC5C,OAAOA;AACT","ignoreList":[0]}},
    {"offset": {"line": 4549, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/normalize-trailing-slash.ts"],"sourcesContent":["import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n"],"names":["normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","parsePath","__NEXT_TRAILING_SLASH","test","removeTrailingSlash","endsWith"],"mappings":"AAQ+BG,QAAQC,GAAG,CAACC,4BAA4B;;;;;+BAD1DL,8BAAAA;;;eAAAA;;;qCAPuB;2BACV;AAMnB,MAAMA,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,kDAAkD;QACrE,OAAOD;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGC,CAAAA,GAAAA,WAAAA,SAAS,EAACR;IAC5C,IAAIE,QAAQC,GAAG,CAACM,qBAAqB,EAAE;;IAUvC,OAAO,GAAGE,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACN,YAAYC,QAAQC,MAAM;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 4582, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/add-base-path.ts"],"sourcesContent":["import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n"],"names":["addBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","path","required","normalizePathTrailingSlash","__NEXT_MANUAL_CLIENT_BASE_PATH","addPathPrefix"],"mappings":"AAGkBE,QAAQC,GAAG,CAACC,sBAAsB;;;;;+BAEpCJ,eAAAA;;;eAAAA;;;+BALc;wCACa;AAE3C,MAAMC,mDAA6D;AAE5D,SAASD,YAAYK,IAAY,EAAEC,QAAkB;IAC1D,OAAOC,CAAAA,GAAAA,wBAAAA,0BAA0B,EAC/BL,QAAQC,GAAG,CAACK,0BACRH,IADsC,IAAI,CAACC,iBAE3CG,CAAAA,GAAAA,eAAAA,aAAa,EAACJ,MAAMJ;AAE5B","ignoreList":[0]}},
    {"offset": {"line": 4610, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/app-router-utils.ts"],"sourcesContent":["import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n"],"names":["createPrefetchURL","isExternalURL","url","origin","window","location","href","isBot","navigator","userAgent","URL","addBasePath","_","Error","process","env","NODE_ENV"],"mappings":"AAgCMc,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;;;;;;;;;;;;IAlBfhB,iBAAiB,EAAA;eAAjBA;;IAXAC,aAAa,EAAA;eAAbA;;;uBAHM;6BACM;AAErB,SAASA,cAAcC,GAAQ;IACpC,OAAOA,IAAIC,MAAM,KAAKC,OAAOC,QAAQ,CAACF,MAAM;AAC9C;AASO,SAASH,kBAAkBM,IAAY;IAC5C,kDAAkD;IAClD,IAAIC,CAAAA,GAAAA,OAAAA,KAAK,EAACH,OAAOI,SAAS,CAACC,SAAS,GAAG;QACrC,OAAO;IACT;IAEA,IAAIP;IACJ,IAAI;QACFA,MAAM,IAAIQ,IAAIC,CAAAA,GAAAA,aAAAA,WAAW,EAACL,OAAOF,OAAOC,QAAQ,CAACC,IAAI;IACvD,EAAE,OAAOM,GAAG;QACV,2EAA2E;QAC3E,kDAAkD;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,iBAAiB,EAAEP,KAAK,0CAA0C,CAAC,GADhE,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,uEAAuE;IACvE,wCAA4C;QAC1C,OAAO;IACT;;;AAQF","ignoreList":[0]}},
    {"offset": {"line": 4673, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/links.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n"],"names":["IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","startTransition","setOptimisticLinkStatus","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","get","undefined","set","observe","coercePrefetchableUrl","href","window","createPrefetchURL","require","reportErrorFn","reportError","console","error","router","fetchStrategy","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","entries","entry","intersectionRatio","target","process","env","NODE_ENV","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","FetchStrategy","Full","Intent","priority","existingPrefetchTask","getCurrentAppRouterState","appRouterState","treeAtTimeOfPrefetch","tree","nextUrl","cacheKey","createCacheKey","scheduleSegmentPrefetchTask","reschedulePrefetchTask","task","isPrefetchTaskDirty"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4971, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/navigation-devtools.ts"],"sourcesContent":["import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { Params } from '../../server/request/params'\nimport {\n  createDevToolsInstrumentedPromise,\n  type InstrumentedPromise,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\n/**\n * Promises are cached by tree to ensure stability across suspense retries.\n */\ntype LayoutSegmentPromisesCache = {\n  selectedLayoutSegmentPromises: Map<string, InstrumentedPromise<string | null>>\n  selectedLayoutSegmentsPromises: Map<string, InstrumentedPromise<string[]>>\n}\n\nconst layoutSegmentPromisesCache = new WeakMap<\n  FlightRouterState,\n  LayoutSegmentPromisesCache\n>()\n\n/**\n * Creates instrumented promises for layout segment hooks at a given tree level.\n * This is dev-only code for React Suspense DevTools instrumentation.\n */\nexport function createLayoutSegmentPromises(\n  tree: FlightRouterState\n): LayoutSegmentPromisesCache | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Check if we already have cached promises for this tree\n  const cached = layoutSegmentPromisesCache.get(tree)\n  if (cached) {\n    return cached\n  }\n\n  // Create new promises and cache them\n  const segmentPromises = new Map<string, InstrumentedPromise<string | null>>()\n  const segmentsPromises = new Map<string, InstrumentedPromise<string[]>>()\n\n  const parallelRoutes = tree[1]\n  for (const parallelRouteKey of Object.keys(parallelRoutes)) {\n    const segments = getSelectedLayoutSegmentPath(tree, parallelRouteKey)\n\n    // Use the shared logic to compute the segment value\n    const segment = computeSelectedLayoutSegment(segments, parallelRouteKey)\n\n    segmentPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegment', segment)\n    )\n    segmentsPromises.set(\n      parallelRouteKey,\n      createDevToolsInstrumentedPromise('useSelectedLayoutSegments', segments)\n    )\n  }\n\n  const result: LayoutSegmentPromisesCache = {\n    selectedLayoutSegmentPromises: segmentPromises,\n    selectedLayoutSegmentsPromises: segmentsPromises,\n  }\n\n  // Cache the result for future renders\n  layoutSegmentPromisesCache.set(tree, result)\n\n  return result\n}\n\nconst rootNavigationPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<string, NavigationPromises>\n>()\n\n/**\n * Creates instrumented navigation promises for the root app-router.\n */\nexport function createRootNavigationPromises(\n  tree: FlightRouterState,\n  pathname: string,\n  searchParams: URLSearchParams,\n  pathParams: Params\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  // Create stable cache keys from the values\n  const searchParamsString = searchParams.toString()\n  const pathParamsString = JSON.stringify(pathParams)\n  const cacheKey = `${pathname}:${searchParamsString}:${pathParamsString}`\n\n  // Get or create the cache for this tree\n  let treeCache = rootNavigationPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<string, NavigationPromises>()\n    rootNavigationPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this combination\n  const cached = treeCache.get(cacheKey)\n  if (cached) {\n    return cached\n  }\n\n  const readonlySearchParams = new ReadonlyURLSearchParams(searchParams)\n\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n\n  const promises: NavigationPromises = {\n    pathname: createDevToolsInstrumentedPromise('usePathname', pathname),\n    searchParams: createDevToolsInstrumentedPromise(\n      'useSearchParams',\n      readonlySearchParams\n    ),\n    params: createDevToolsInstrumentedPromise('useParams', pathParams),\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(cacheKey, promises)\n\n  return promises\n}\n\nconst nestedLayoutPromisesCache = new WeakMap<\n  FlightRouterState,\n  Map<NavigationPromises | null, NavigationPromises>\n>()\n\n/**\n * Creates merged navigation promises for nested layouts.\n * Merges parent promises with layout-specific segment promises.\n */\nexport function createNestedLayoutNavigationPromises(\n  tree: FlightRouterState,\n  parentNavPromises: NavigationPromises | null\n): NavigationPromises | null {\n  if (process.env.NODE_ENV === 'production') {\n    return null\n  }\n\n  const parallelRoutes = tree[1]\n  const parallelRouteKeys = Object.keys(parallelRoutes)\n\n  // Only create promises if there are parallel routes at this level\n  if (parallelRouteKeys.length === 0) {\n    return null\n  }\n\n  // Get or create the cache for this tree\n  let treeCache = nestedLayoutPromisesCache.get(tree)\n  if (!treeCache) {\n    treeCache = new Map<NavigationPromises | null, NavigationPromises>()\n    nestedLayoutPromisesCache.set(tree, treeCache)\n  }\n\n  // Check if we have cached promises for this parent combination\n  const cached = treeCache.get(parentNavPromises)\n  if (cached) {\n    return cached\n  }\n\n  // Create merged promises\n  const layoutSegmentPromises = createLayoutSegmentPromises(tree)\n  const promises: NavigationPromises = {\n    ...parentNavPromises!,\n    ...layoutSegmentPromises,\n  }\n\n  treeCache.set(parentNavPromises, promises)\n\n  return promises\n}\n"],"names":["createLayoutSegmentPromises","createNestedLayoutNavigationPromises","createRootNavigationPromises","layoutSegmentPromisesCache","WeakMap","tree","process","env","NODE_ENV","cached","get","segmentPromises","Map","segmentsPromises","parallelRoutes","parallelRouteKey","Object","keys","segments","getSelectedLayoutSegmentPath","segment","computeSelectedLayoutSegment","set","createDevToolsInstrumentedPromise","result","selectedLayoutSegmentPromises","selectedLayoutSegmentsPromises","rootNavigationPromisesCache","pathname","searchParams","pathParams","searchParamsString","toString","pathParamsString","JSON","stringify","cacheKey","treeCache","readonlySearchParams","ReadonlyURLSearchParams","layoutSegmentPromises","promises","params","nestedLayoutPromisesCache","parentNavPromises","parallelRouteKeys","length"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5100, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx"],"sourcesContent":["'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","process","env","NODE_ENV","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","warnOnce","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5229, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/dev-root-http-access-fallback-boundary.tsx"],"sourcesContent":["'use client'\n\nimport React from 'react'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\n\n// TODO: error on using forbidden and unauthorized in root layout\nexport function bailOnRootNotFound() {\n  throw new Error('notFound() is not allowed to use in root layout')\n}\n\nfunction NotAllowedRootHTTPFallbackError() {\n  bailOnRootNotFound()\n  return null\n}\n\nexport function DevRootHTTPAccessFallbackBoundary({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <HTTPAccessFallbackBoundary notFound={<NotAllowedRootHTTPFallbackError />}>\n      {children}\n    </HTTPAccessFallbackBoundary>\n  )\n}\n"],"names":["DevRootHTTPAccessFallbackBoundary","bailOnRootNotFound","Error","NotAllowedRootHTTPFallbackError","children","HTTPAccessFallbackBoundary","notFound"],"mappings":";;;;;;;;;;;;;;IAegBA,iCAAiC,EAAA;eAAjCA;;IATAC,kBAAkB,EAAA;eAAlBA;;;;;gEAJE;+BACyB;AAGpC,SAASA;IACd,MAAM,OAAA,cAA4D,CAA5D,IAAIC,MAAM,oDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAA2D;AACnE;AAEA,SAASC;IACPF;IACA,OAAO;AACT;AAEO,SAASD,kCAAkC,EAChDI,QAAQ,EAGT;IACC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,eAAAA,0BAA0B,EAAA;QAACC,UAAAA,WAAAA,GAAU,CAAA,GAAA,YAAA,GAAA,EAACH,iCAAAA,CAAAA;kBACpCC;;AAGP","ignoreList":[0]}},
    {"offset": {"line": 5282, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/app-router.tsx"],"sourcesContent":["import React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type {\n  AppHistoryState,\n  AppRouterState,\n} from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\nimport type { StaticIndicatorState } from '../dev/hot-reloader/app/hot-reloader-app'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl, renderedSearch } = appRouterState\n\n    const appHistoryState: AppHistoryState = {\n      tree,\n      renderedSearch,\n    }\n\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: appHistoryState,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  globalError,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalError: GlobalErrorState\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { cache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        tree,\n      }\n    }, [cache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        historyState: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const appHistoryState: AppHistoryState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          historyState: appHistoryState,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef, previousNextUrl } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  // Create instrumented promises for navigation hooks (dev-only)\n  // These are specially instrumented promises to show in the Suspense DevTools\n  // Promises are cached outside of render to survive suspense retries.\n  let instrumentedNavigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createRootNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    instrumentedNavigationPromises = createRootNavigationPromises(\n      tree,\n      pathname,\n      searchParams,\n      pathParams\n    )\n  }\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      parentParams: {},\n      // This is the <Activity> \"name\" that shows up in the Suspense DevTools.\n      // It represents the root of the app.\n      debugNameContext: '/',\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n      // Root segment is always active\n      isActive: true,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n      previousNextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl, previousNextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader\n        globalError={globalError}\n        webSocket={webSocket}\n        staticIndicatorState={staticIndicatorState}\n      >\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <NavigationPromisesContext.Provider\n        value={instrumentedNavigationPromises}\n      >\n        <PathParamsContext.Provider value={pathParams}>\n          <PathnameContext.Provider value={pathname}>\n            <SearchParamsContext.Provider value={searchParams}>\n              <GlobalLayoutRouterContext.Provider\n                value={globalLayoutRouterContext}\n              >\n                {/* TODO: We should be able to remove this context. useRouter\n                    should import from app-router-instance instead. It's only\n                    necessary because useRouter is shared between Pages and\n                    App Router. We should fork that module, then remove this\n                    context provider. */}\n                <AppRouterContext.Provider value={publicAppRouterInstance}>\n                  <LayoutRouterContext.Provider value={layoutRouterContext}>\n                    {content}\n                  </LayoutRouterContext.Provider>\n                </AppRouterContext.Provider>\n              </GlobalLayoutRouterContext.Provider>\n            </SearchParamsContext.Provider>\n          </PathnameContext.Provider>\n        </PathParamsContext.Provider>\n      </NavigationPromisesContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  webSocket,\n  staticIndicatorState,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  webSocket?: WebSocket\n  staticIndicatorState?: StaticIndicatorState\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      globalError={globalErrorState}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n"],"names":["createEmptyCacheNode","AppRouter","globalMutable","HistoryUpdater","appRouterState","useInsertionEffect","process","env","__NEXT_APP_NAV_FAIL_HANDLING","window","next","__pendingUrl","undefined","tree","pushRef","canonicalUrl","renderedSearch","appHistoryState","historyState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","URL","location","href","pushState","replaceState","useEffect","pingVisibleLinks","nextUrl","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","Map","loading","navigatedAt","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","Router","actionQueue","globalError","webSocket","staticIndicatorState","useActionQueue","searchParams","pathname","useMemo","url","hasBasePath","removeBasePath","NODE_ENV","cache","nd","router","publicAppRouterInstance","handlePageShow","event","persisted","pendingMpaPath","dispatchAppRouterAction","type","ACTION_RESTORE","addEventListener","removeEventListener","handleUnhandledRedirect","error","reason","isRedirectError","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","push","replace","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","startTransition","_unused","_N","onPopState","reload","dispatchTraverseAction","focusAndScrollRef","previousNextUrl","matchingHead","findHeadInCache","pathParams","getSelectedParams","instrumentedNavigationPromises","createRootNavigationPromises","require","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","debugNameContext","isActive","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","AppRouterAnnouncer","DevRootHTTPAccessFallbackBoundary","HotReloader","default","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","NavigationPromisesContext","Provider","value","PathParamsContext","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","Set","runtimeStyleChanged","globalThis","_N_E_STYLE_LOAD","len","size","add","forEach","cb","Promise","resolve","forceUpdate","React","useState","renderedStylesSize","changed","c","delete","dplId","NEXT_DEPLOYMENT_ID","map","i","link","rel","precedence"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5800, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const { serverResponse, navigatedAt } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof serverResponse === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      serverResponse,\n      state.pushRef.pendingPush\n    )\n  }\n\n  const { flightData, canonicalUrl, renderedSearch } = serverResponse\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.renderedSearch = renderedSearch\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n"],"names":["serverPatchReducer","state","action","serverResponse","navigatedAt","mutable","preserveCustomHistoryState","handleExternalUrl","pushRef","pendingPush","flightData","canonicalUrl","renderedSearch","currentTree","tree","currentCache","cache","normalizedFlightData","segmentPath","flightSegmentPath","treePatch","newTree","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","createHrefFromUrl","createEmptyCacheNode","applyFlightData","patchedTree","handleMutable"],"mappings":";;;+BAegBA,sBAAAA;;;eAAAA;;;mCAfkB;6CACU;6CACA;iCAOV;iCACF;+BACF;2BAEO;AAE9B,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,cAAc,EAAEC,WAAW,EAAE,GAAGF;IAExC,MAAMG,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOH,mBAAmB,UAAU;QACtC,OAAOI,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBN,OACAI,SACAF,gBACAF,MAAMO,OAAO,CAACC,WAAW;IAE7B;IAEA,MAAM,EAAEC,UAAU,EAAEC,YAAY,EAAEC,cAAc,EAAE,GAAGT;IAErD,IAAIU,cAAcZ,MAAMa,IAAI;IAC5B,IAAIC,eAAed,MAAMe,KAAK;IAE9B,KAAK,MAAMC,wBAAwBP,WAAY;QAC7C,MAAM,EAAEQ,aAAaC,iBAAiB,EAAEL,MAAMM,SAAS,EAAE,GACvDH;QAEF,MAAMI,UAAUC,CAAAA,GAAAA,6BAAAA,2BAA2B,EACzC,AACA,sBADsB;YACrB;eAAOH;SAAkB,EAC1BN,aACAO,WACAnB,MAAMU,YAAY;QAGpB,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAIU,YAAY,MAAM;YACpB,OAAOpB;QACT;QAEA,IAAIsB,CAAAA,GAAAA,6BAAAA,2BAA2B,EAACV,aAAaQ,UAAU;YACrD,OAAOd,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBN,OACAI,SACAJ,MAAMU,YAAY,EAClBV,MAAMO,OAAO,CAACC,WAAW;QAE7B;QAEAJ,QAAQM,YAAY,GAAGa,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACb;QAEzC,MAAMK,QAAmBS,CAAAA,GAAAA,WAAAA,oBAAoB;QAC7CC,CAAAA,GAAAA,iBAAAA,eAAe,EAACtB,aAAaW,cAAcC,OAAOC;QAElDZ,QAAQsB,WAAW,GAAGN;QACtBhB,QAAQO,cAAc,GAAGA;QACzBP,QAAQW,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,OAAOO,CAAAA,GAAAA,eAAAA,aAAa,EAAC3B,OAAOI;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 5866, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment  a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation  but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldUrl,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[0]\n    loading = prefetchData[2]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[3]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): Task {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (result: FetchServerResponseResult) => {\n      if (typeof result === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      const { flightData, debugInfo } = result\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          debugInfo\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null, debugInfo)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error, null)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading:\n      prefetchData !== null\n        ? (prefetchData[2] ?? null)\n        : // If we don't have a prefetch, then we don't know if there's a loading component.\n          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n          createDeferredRsc<LoadingModuleData>(),\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            debugInfo\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: SPANavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n"],"names":["abortTask","listenForDynamicRequest","startPPRNavigation","updateCacheNodeOnPopstateRestoration","MPA_NAVIGATION_TASK","route","node","dynamicRequestTree","children","navigatedAt","oldUrl","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","segmentPath","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","isRootLayout","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentPathChild","concat","newSegmentKeyChild","createRouterCacheKey","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","DEFAULT_SEGMENT_KEY","reuseActiveSegmentInDefaultSlot","beginRenderingNewRouteTree","Object","keys","length","matchSegment","set","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","isNavigatingToNewRootLayout","createCacheNodeOnNavigation","routerState","routerStateChildren","isLeafSegment","cacheNodeNavigatedAt","DYNAMIC_STALETIME_MS","isPrefetchRscPartial","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","push","routerStateChild","existingSegmentMapChild","segmentChild","segmentPathChild","segmentKeyChild","existingCacheNodeChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","reusedRouterState","oldRefreshMarker","createHrefFromUrl","task","responsePromise","then","result","flightData","debugInfo","normalizedFlightData","tree","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","size","maybePrefetchRsc","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","dynamicLoading","values","reject","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6741, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, historyState } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n"],"names":["restoreReducer","state","action","url","historyState","href","createHrefFromUrl","treeToRestore","renderedSearch","tree","oldCache","cache","newCache","process","env","__NEXT_PPR","updateCacheNodeOnPopstateRestoration","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","nextUrl","extractPathFromFlightRouterState","pathname","previousNextUrl","debugInfo"],"mappings":"AAiCmBa,QAAQC,GAAG,CAACC,UAAU,GAEnC,qEAAqE;;;;;+BAzB3Df,kBAAAA;;;eAAAA;;;mCAVkB;oCAMe;gCACI;AAG9C,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,YAAY,EAAE,GAAGF;IAC9B,MAAMG,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACH;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,IAAII;IACJ,IAAIC;IACJ,IAAIJ,cAAc;QAChBG,gBAAgBH,aAAaK,IAAI;QACjCD,iBAAiBJ,aAAaI,cAAc;IAC9C,OAAO;QACLD,gBAAgBN,MAAMQ,IAAI;QAC1BD,iBAAiBP,MAAMO,cAAc;IACvC;IAEA,MAAME,WAAWT,MAAMU,KAAK;IAC5B,MAAMC,iDAGF,2DAA2D;IAC3D,2BAA2B;IAC3BI,IAAAA,sBACAN,8BADoC,EAACA,UAAUH;IAGnD,OAAO;QACL,oBAAoB;QACpBU,cAAcZ;QACdG;QACAU,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBrB,MAAMqB,iBAAiB;QAC1CX,OAAOC;QACP,wBAAwB;QACxBH,MAAMF;QACNgB,SAASC,CAAAA,GAAAA,oBAAAA,gCAAgC,EAACjB,kBAAkBJ,IAAIsB,QAAQ;QACxEC,iBAAiB;QACjBC,WAAW;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 6807, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/handle-segment-mismatch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n"],"names":["handleSegmentMismatch","state","action","treePatch","process","env","NODE_ENV","console","warn","type","JSON","stringify","tree","handleExternalUrl","canonicalUrl"],"mappings":"AAgBMI,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BALfN,yBAAAA;;;eAAAA;;;iCAVkB;AAU3B,SAASA,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,wCAA4C;QAC1CI,QAAQC,IAAI,CACV,sJACE,+BACA,CAAC,aAAa,EAAEN,OAAOO,IAAI,CAAC,IAAI,CAAC,GACjC,CAAC,cAAc,EAAEC,KAAKC,SAAS,CAACV,MAAMW,IAAI,EAAE,IAAI,CAAC,GACjD,CAAC,oBAAoB,EAAEF,KAAKC,SAAS,CAACR,YAAY;IAExD;IAEA,OAAOU,CAAAA,GAAAA,iBAAAA,iBAAiB,EAACZ,OAAO,CAAC,GAAGA,MAAMa,YAAY,EAAE;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 6836, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key"],"mappings":";;;+BAGgBA,qCAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,kCAAkC,CAChDC,SACAC,eACkB;IAClB,wGAAwG;IACxG,IACEC,MAAMC,OAAO,CAACH,YACbA,CAAAA,OAAO,CAAC,EAAE,KAAK,gBACdA,OAAO,CAAC,EAAE,KAAK,gBACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,WACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,YACfA,OAAO,CAAC,EAAE,KAAK,aACfA,OAAO,CAAC,EAAE,KAAK,SAAQ,GACzB;QACA,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 6876, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const loading = cacheNodeSeedData[2]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          revalidateEntireCache(state.nextUrl, newTree)\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","createEmptyCacheNode","includeNextUrl","hasInterceptionRouteInCurrentTree","lazyData","fetchServerResponse","URL","flightRouterState","nextUrl","navigatedAt","Date","now","then","result","handleExternalUrl","pushRef","pendingPush","flightData","renderedSearch","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","createHrefFromUrl","rsc","loading","prefetchRsc","fillLazyItemsTillLeafWithHead","undefined","revalidateEntireCache","refreshInactiveParallelSegments","updatedTree","updatedCache","patchedTree","handleMutable"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6985, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    (result: FetchServerResponseResult) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof result === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          result,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const { flightData, canonicalUrl, renderedSearch } = result\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.renderedSearch = renderedSearch\n        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n"],"names":["hmrRefreshReducer","hmrRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","createEmptyCacheNode","includeNextUrl","hasInterceptionRouteInCurrentTree","tree","navigatedAt","Date","now","lazyData","fetchServerResponse","URL","flightRouterState","nextUrl","isHmrRefresh","then","result","handleExternalUrl","pushRef","pendingPush","flightData","renderedSearch","currentTree","currentCache","normalizedFlightData","treePatch","isRootRender","console","log","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","applied","applyFlightData","patchedTree","createHrefFromUrl","handleMutable","hmrRefreshReducerNoop","_action","process","env","NODE_ENV"],"mappings":"AA+HEgD,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BADdlD,qBAAAA;;;eAAAA;;;qCA3HN;mCAC2B;6CACU;6CACA;iCAOV;+BACJ;iCACE;2BAEK;uCACC;mDACY;AAElD,wFAAwF;AACxF,SAASC,sBACPC,KAA2B,EAC3BC,MAAwB;IAExB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/BF,QAAQG,0BAA0B,GAAG;IAErC,MAAMC,QAAmBC,CAAAA,GAAAA,WAAAA,oBAAoB;IAC7C,sFAAsF;IACtF,sHAAsH;IACtH,MAAMC,iBAAiBC,CAAAA,GAAAA,mCAAAA,iCAAiC,EAACV,MAAMW,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxC,MAAMC,cAAcC,KAAKC,GAAG;IAC5BP,MAAMQ,QAAQ,GAAGC,CAAAA,GAAAA,qBAAAA,mBAAmB,EAAC,IAAIC,IAAIb,MAAMF,SAAS;QAC1DgB,mBAAmB;YAAClB,MAAMW,IAAI,CAAC,EAAE;YAAEX,MAAMW,IAAI,CAAC,EAAE;YAAEX,MAAMW,IAAI,CAAC,EAAE;YAAE;SAAU;QAC3EQ,SAASV,iBAAiBT,MAAMmB,OAAO,GAAG;QAC1CC,cAAc;IAChB;IAEA,OAAOb,MAAMQ,QAAQ,CAACM,IAAI,CACxB,CAACC;QACC,4DAA4D;QAC5D,IAAI,OAAOA,WAAW,UAAU;YAC9B,OAAOC,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBvB,OACAG,SACAmB,QACAtB,MAAMwB,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAM,EAAEC,UAAU,EAAErB,YAAY,EAAEsB,cAAc,EAAE,GAAGL;QAErD,+DAA+D;QAC/Df,MAAMQ,QAAQ,GAAG;QAEjB,IAAIa,cAAc5B,MAAMW,IAAI;QAC5B,IAAIkB,eAAe7B,MAAMO,KAAK;QAE9B,KAAK,MAAMuB,wBAAwBJ,WAAY;YAC7C,MAAM,EAAEf,MAAMoB,SAAS,EAAEC,YAAY,EAAE,GAAGF;YAC1C,IAAI,CAACE,cAAc;gBACjB,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAOlC;YACT;YAEA,MAAMmC,UAAUC,CAAAA,GAAAA,6BAAAA,2BAA2B,EACzC,AACA,sBADsB;gBACrB;aAAG,EACJR,aACAG,WACA/B,MAAMK,YAAY;YAGpB,IAAI8B,YAAY,MAAM;gBACpB,OAAOE,CAAAA,GAAAA,uBAAAA,qBAAqB,EAACrC,OAAOC,QAAQ8B;YAC9C;YAEA,IAAIO,CAAAA,GAAAA,6BAAAA,2BAA2B,EAACV,aAAaO,UAAU;gBACrD,OAAOZ,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBvB,OACAG,SACAC,MACAJ,MAAMwB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMc,UAAUC,CAAAA,GAAAA,iBAAAA,eAAe,EAC7B5B,aACAiB,cACAtB,OACAuB;YAGF,IAAIS,SAAS;gBACXpC,QAAQI,KAAK,GAAGA;gBAChBsB,eAAetB;YACjB;YAEAJ,QAAQsC,WAAW,GAAGN;YACtBhC,QAAQwB,cAAc,GAAGA;YACzBxB,QAAQE,YAAY,GAAGqC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACrC;YAEzCuB,cAAcO;QAChB;QACA,OAAOQ,CAAAA,GAAAA,eAAAA,aAAa,EAAC3C,OAAOG;IAC9B,GACA,IAAMH;AAEV;AAEA,SAAS4C,sBACP5C,KAA2B,EAC3B6C,OAAyB;IAEzB,OAAO7C;AACT;AAEO,MAAMF,0DAEP8C,0BACA7C","ignoreList":[0]}},
    {"offset": {"line": 7083, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/assign-location.ts"],"sourcesContent":["import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n"],"names":["assignLocation","location","url","startsWith","urlBase","origin","pathname","URL","endsWith","addBasePath","href"],"mappings":";;;+BASgBA,kBAAAA;;;eAAAA;;;6BATY;AASrB,SAASA,eAAeC,QAAgB,EAAEC,GAAQ;IACvD,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,UAAUF,IAAIG,MAAM,GAAGH,IAAII,QAAQ;QACzC,OAAO,IAAIC,IACT,AAGA,AAFA,6FAA6F,kBADkB;QAE/G,qGAAqG;QACpGH,CAAAA,QAAQI,QAAQ,CAAC,OAAOJ,UAAUA,UAAU,GAAE,IAAKH;IAExD;IAEA,OAAO,IAAIM,IAAIE,CAAAA,GAAAA,aAAAA,WAAW,EAACR,WAAWC,IAAIQ,IAAI;AAChD","ignoreList":[0]}},
    {"offset": {"line": 7113, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      // Store whether this action triggered any revalidation\n      // The action queue will use this information to potentially\n      // trigger a refresh action if the action was discarded\n      // (ie, due to a navigation, before the action completed)\n      if (actionRevalidated) {\n        action.didRevalidate = true\n      }\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[2]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          revalidateEntireCache(state.nextUrl, newTree)\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const redirectError = getRedirectError(\n          hasBasePath(redirectHref)\n            ? removeBasePath(redirectHref)\n            : redirectHref,\n          redirectType || RedirectType.push\n        )\n        // We mark the error as handled because we don't want the redirect to be tried later by\n        // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n        // again, as it's run within an effect.\n        // We don't actually need the RedirectBoundary to do a router.push because we already\n        // have all the necessary RSC data to render the new page within a single roundtrip.\n        ;(redirectError as any).handled = true\n        reject(redirectError)\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","info","extractInfoFromServerReferenceId","usedArgs","type","omitUnusedArgs","body","encodeReply","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","tree","NEXT_DEPLOYMENT_ID","NEXT_URL","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","location","_redirectType","split","redirectType","RedirectType","push","replace","undefined","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidatedParts","revalidatedHeader","JSON","parse","paths","tag","cookie","e","NO_REVALIDATED_PARTS","redirectLocation","assignLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","response","Promise","resolve","callServer","findSourceMapURL","debugChannel","a","normalizeFlightData","f","action","reject","mutable","currentTree","preserveCustomHistoryState","previousNextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","then","flightData","redirectHref","pushRef","pendingPush","createHrefFromUrl","handleExternalUrl","actionRevalidated","length","didRevalidate","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","rsc","cache","createEmptyCacheNode","prefetchRsc","loading","fillLazyItemsTillLeafWithHead","revalidateEntireCache","refreshInactiveParallelSegments","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","redirectError","getRedirectError","hasBasePath","removeBasePath","handled","handleMutable"],"mappings":"AAmEEI,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBACzBF,QAAQC,GAAG,CAACE,0BAA0B,EACtC;;;;;+BA4KcP,uBAAAA;;;eAAAA;;;+BA7OW;qCACM;kCAU1B;yCACiC;wBAQjC;gCAQwB;mCACG;iCACA;6CACU;6CACA;+BAEd;+CACgB;2BACT;mDACa;uCACZ;iDACU;mCAKzC;0BAC0B;+BACJ;gCACE;6BACH;qCAIrB;uBAC+B;;;;;AAEtC,MAAMC,kBACJC,QAAAA,eAAsB;AAExB,IAAIC;AAIJ;;AAsBA,eAAeM,kBACbC,KAA2B,EAC3BC,OAAwC,EACxC,EAAEC,QAAQ,EAAEC,UAAU,EAAsB;IAE5C,MAAMC,sBAAsBC,CAAAA,GAAAA,QAAAA,2BAA2B;IACvD,MAAMC,OAAOC,CAAAA,GAAAA,qBAAAA,gCAAgC,EAACL;IAE9C,6EAA6E;IAC7E,8EAA8E;IAC9E,+CAA+C;IAC/C,MAAMM,WACJF,KAAKG,IAAI,KAAK,cAAcC,CAAAA,GAAAA,qBAAAA,cAAc,EAACP,YAAYG,QAAQH;IAEjE,MAAMQ,OAAO,MAAMC,CAAAA,GAAAA,QAAAA,WAAW,EAACJ,UAAU;QAAEJ;IAAoB;IAE/D,MAAMS,UAAkC;QACtCC,QAAQC,kBAAAA,uBAAuB;QAC/B,CAACC,kBAAAA,aAAa,CAAC,EAAEd;QACjB,CAACe,kBAAAA,6BAA6B,CAAC,EAAEC,CAAAA,GAAAA,mBAAAA,kCAAkC,EACjElB,MAAMmB,IAAI;IAEd;IAEA,IAAIzB,QAAQC,GAAG,CAACyB,kBAAkB,EAAE;;IAIpC,IAAInB,SAAS;QACXY,OAAO,CAACQ,kBAAAA,QAAQ,CAAC,GAAGpB;IACtB;IAEA,IAAIP,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,IAAI0B,KAAKC,QAAQ,EAAE;YACjBV,OAAO,CAACW,kBAAAA,2BAA2B,CAAC,GAAGF,KAAKC,QAAQ;QACtD;QAEA,yEAAyE;QACzE,wEAAwE;QACxE,yEAAyE;QACzEV,OAAO,CAACY,kBAAAA,sBAAsB,CAAC,GAAGC,OAC/BC,eAAe,CAAC,IAAIC,YAAY,GAAG,CAAC,EAAE,CACtCC,QAAQ,CAAC;IACd;IAEA,MAAMC,MAAM,MAAMC,MAAM/B,MAAMgC,YAAY,EAAE;QAAEC,QAAQ;QAAQpB;QAASF;IAAK;IAE5E,0DAA0D;IAC1D,MAAMuB,2BAA2BJ,IAAIjB,OAAO,CAACsB,GAAG,CAACC,kBAAAA,4BAA4B;IAC7E,IAAIF,6BAA6B,KAAK;QACpC,MAAM,OAAA,cAEL,CAFK,IAAIG,yBAAAA,uBAAuB,CAC/B,CAAC,eAAe,EAAEnC,SAAS,yGAAyG,CAAC,GADjI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMoC,iBAAiBR,IAAIjB,OAAO,CAACsB,GAAG,CAAC;IACvC,MAAM,CAACI,UAAUC,cAAc,GAAGF,gBAAgBG,MAAM,QAAQ,EAAE;IAClE,IAAIC;IACJ,OAAQF;QACN,KAAK;YACHE,eAAeC,eAAAA,YAAY,CAACC,IAAI;YAChC;QACF,KAAK;YACHF,eAAeC,eAAAA,YAAY,CAACE,OAAO;YACnC;QACF;YACEH,eAAeI;IACnB;IAEA,MAAMC,cAAc,CAAC,CAACjB,IAAIjB,OAAO,CAACsB,GAAG,CAACa,kBAAAA,wBAAwB;IAC9D,IAAIC;IACJ,IAAI;QACF,MAAMC,oBAAoBC,KAAKC,KAAK,CAClCtB,IAAIjB,OAAO,CAACsB,GAAG,CAAC,2BAA2B;QAE7Cc,mBAAmB;YACjBI,OAAOH,iBAAiB,CAAC,EAAE,IAAI,EAAE;YACjCI,KAAK,CAAC,CAACJ,iBAAiB,CAAC,EAAE;YAC3BK,QAAQL,iBAAiB,CAAC,EAAE;QAC9B;IACF,EAAE,OAAOM,GAAG;QACVP,mBAAmBQ;IACrB;IAEA,MAAMC,mBAAmBnB,WACrBoB,CAAAA,GAAAA,gBAAAA,cAAc,EACZpB,UACA,IAAIqB,IAAI5D,MAAMgC,YAAY,EAAE6B,OAAOtB,QAAQ,CAACuB,IAAI,KAElDhB;IAEJ,MAAMiB,cAAcjC,IAAIjB,OAAO,CAACsB,GAAG,CAAC;IACpC,MAAM6B,gBAAgB,CAAC,CACrBD,CAAAA,eAAeA,YAAYE,UAAU,CAAClD,kBAAAA,uBAAuB,CAAA;IAG/D,0CAA0C;IAC1C,iGAAiG;IACjG,iGAAiG;IACjG,IAAI,CAACiD,iBAAiB,CAACN,kBAAkB;QACvC,kGAAkG;QAClG,sBAAsB;QACtB,MAAMQ,UACJpC,IAAIqC,MAAM,IAAI,OAAOJ,gBAAgB,eACjC,MAAMjC,IAAIsC,IAAI,KACd;QAEN,MAAM,OAAA,cAAkB,CAAlB,IAAIC,MAAMH,UAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAiB;IACzB;IAEA,IAAII;IACJ,IAAIC;IAEJ,IAAIP,eAAe;QACjB,MAAMQ,WAAiC,MAAMjF,gBAC3CkF,QAAQC,OAAO,CAAC5C,MAChB;YACE6C,YAAAA,eAAAA,UAAU;YACVC,kBAAAA,qBAAAA,gBAAgB;YAChBxE;YACAyE,cAAcpF,sBAAsBA,mBAAmBoB;QACzD;QAGF,4FAA4F;QAC5FyD,eAAeZ,mBAAmBZ,YAAY0B,SAASM,CAAC;QACxDP,mBAAmBQ,CAAAA,GAAAA,mBAAAA,mBAAmB,EAACP,SAASQ,CAAC;IACnD,OAAO;QACL,iDAAiD;QACjDV,eAAexB;QACfyB,mBAAmBzB;IACrB;IAEA,OAAO;QACLwB;QACAC;QACAb;QACAhB;QACAO;QACAF;IACF;AACF;AAEA,MAAMU,uBAAuB;IAC3BJ,OAAO,EAAE;IACTC,KAAK;IACLC,QAAQ;AACV;AAMO,SAASjE,oBACdU,KAA2B,EAC3BiF,MAA0B;IAE1B,MAAM,EAAEP,OAAO,EAAEQ,MAAM,EAAE,GAAGD;IAC5B,MAAME,UAA+B,CAAC;IAEtC,IAAIC,cAAcpF,MAAMmB,IAAI;IAE5BgE,QAAQE,0BAA0B,GAAG;IAErC,2GAA2G;IAC3G,mEAAmE;IACnE,4EAA4E;IAC5E,wDAAwD;IACxD,MAAMpF,UAMJ,AALA,AACA,yDADyD,CACC;IAC1D,wDAAwD;IACxD,sDAAsD;IACtD,YAAY;IACXD,CAAAA,MAAMsF,eAAe,IAAItF,MAAMC,OAAM,KACtCsF,CAAAA,GAAAA,mCAAAA,iCAAiC,EAACvF,MAAMmB,IAAI,IACxCnB,MAAMsF,eAAe,IAAItF,MAAMC,OAAO,GACtC;IAEN,MAAMuF,cAAcC,KAAKC,GAAG;IAE5B,OAAO3F,kBAAkBC,OAAOC,SAASgF,QAAQU,IAAI,CACnD,OAAO,EACLrB,YAAY,EACZC,kBAAkBqB,UAAU,EAC5BlC,gBAAgB,EAChBhB,YAAY,EACZO,gBAAgB,EACjB;QACC,IAAI4C;QAEJ,mFAAmF;QACnF,IAAInC,kBAAkB;YACpB,IAAIhB,iBAAiBC,eAAAA,YAAY,CAACE,OAAO,EAAE;gBACzC7C,MAAM8F,OAAO,CAACC,WAAW,GAAG;gBAC5BZ,QAAQY,WAAW,GAAG;YACxB,OAAO;gBACL/F,MAAM8F,OAAO,CAACC,WAAW,GAAG;gBAC5BZ,QAAQY,WAAW,GAAG;YACxB;YAEAF,eAAeG,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACtC,kBAAkB;YACnDyB,QAAQnD,YAAY,GAAG6D;QACzB;QAEA,IAAI,CAACD,YAAY;YACflB,QAAQJ;YAER,2EAA2E;YAC3E,IAAIZ,kBAAkB;gBACpB,OAAOuC,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBjG,OACAmF,SACAzB,iBAAiBI,IAAI,EACrB9D,MAAM8F,OAAO,CAACC,WAAW;YAE7B;YACA,OAAO/F;QACT;QAEA,IAAI,OAAO4F,eAAe,UAAU;YAClC,4DAA4D;YAC5DlB,QAAQJ;YAER,OAAO2B,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBjG,OACAmF,SACAS,YACA5F,MAAM8F,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMG,oBACJjD,iBAAiBI,KAAK,CAAC8C,MAAM,GAAG,KAChClD,iBAAiBK,GAAG,IACpBL,iBAAiBM,MAAM;QAEzB,uDAAuD;QACvD,4DAA4D;QAC5D,uDAAuD;QACvD,yDAAyD;QACzD,IAAI2C,mBAAmB;YACrBjB,OAAOmB,aAAa,GAAG;QACzB;QAEA,KAAK,MAAMC,wBAAwBT,WAAY;YAC7C,MAAM,EACJzE,MAAMmF,SAAS,EACfC,UAAUC,iBAAiB,EAC3BC,IAAI,EACJC,YAAY,EACb,GAAGL;YAEJ,IAAI,CAACK,cAAc;gBACjB,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZlC,QAAQJ;gBAER,OAAOtE;YACT;YAEA,mGAAmG;YACnG,MAAM6G,UAAUC,CAAAA,GAAAA,6BAAAA,2BAA2B,EACzC,AACA,sBADsB;gBACrB;aAAG,EACJ1B,aACAkB,WACAT,eAAeA,eAAe7F,MAAMgC,YAAY;YAGlD,IAAI6E,YAAY,MAAM;gBACpBnC,QAAQJ;gBAER,OAAOyC,CAAAA,GAAAA,uBAAAA,qBAAqB,EAAC/G,OAAOiF,QAAQqB;YAC9C;YAEA,IAAIU,CAAAA,GAAAA,6BAAAA,2BAA2B,EAAC5B,aAAayB,UAAU;gBACrDnC,QAAQJ;gBAER,OAAO2B,CAAAA,GAAAA,iBAAAA,iBAAiB,EACtBjG,OACAmF,SACAU,gBAAgB7F,MAAMgC,YAAY,EAClChC,MAAM8F,OAAO,CAACC,WAAW;YAE7B;YAEA,4FAA4F;YAC5F,IAAIS,sBAAsB,MAAM;gBAC9B,MAAMS,MAAMT,iBAAiB,CAAC,EAAE;gBAChC,MAAMU,QAAmBC,CAAAA,GAAAA,WAAAA,oBAAoB;gBAC7CD,MAAMD,GAAG,GAAGA;gBACZC,MAAME,WAAW,GAAG;gBACpBF,MAAMG,OAAO,GAAGb,iBAAiB,CAAC,EAAE;gBACpCc,CAAAA,GAAAA,+BAAAA,6BAA6B,EAC3B9B,aACA0B,OACA,AACApE,WACAwD,WACAE,mBACAC,gDAJyF;gBAO3FtB,QAAQ+B,KAAK,GAAGA;gBAChBK,CAAAA,GAAAA,OAAAA,qBAAqB,EAACvH,MAAMC,OAAO,EAAE4G;gBACrC,IAAIX,mBAAmB;oBACrB,MAAMsB,CAAAA,GAAAA,iCAAAA,+BAA+B,EAAC;wBACpChC;wBACAxF;wBACAyH,aAAaZ;wBACba,cAAcR;wBACdS,gBAAgBC,QAAQ3H;wBACxB+B,cAAcmD,QAAQnD,YAAY,IAAIhC,MAAMgC,YAAY;oBAC1D;gBACF;YACF;YAEAmD,QAAQ0C,WAAW,GAAGhB;YACtBzB,cAAcyB;QAChB;QAEA,IAAInD,oBAAoBmC,cAAc;YACpC,+EAA+E;YAC/E,+EAA+E;YAC/E,sFAAsF;YACtF,oFAAoF;YACpF,mFAAmF;YACnF,2CAA2C;YAC3C,MAAMiC,gBAAgBC,CAAAA,GAAAA,UAAAA,gBAAgB,EACpCC,CAAAA,GAAAA,aAAAA,WAAW,EAACnC,gBACRoC,CAAAA,GAAAA,gBAAAA,cAAc,EAACpC,gBACfA,cACJnD,gBAAgBC,eAAAA,YAAY,CAACC,IAAI;YAOjCkF,cAAsBI,OAAO,GAAG;YAClChD,OAAO4C;QACT,OAAO;YACLpD,QAAQJ;QACV;QAEA,OAAO6D,CAAAA,GAAAA,eAAAA,aAAa,EAACnI,OAAOmF;IAC9B,GACA,CAAC3B;QACC,mHAAmH;QACnH0B,OAAO1B;QAEP,OAAOxD;IACT;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 7395, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["reducer","clientReducer","state","action","type","ACTION_NAVIGATE","navigateReducer","ACTION_SERVER_PATCH","serverPatchReducer","ACTION_RESTORE","restoreReducer","ACTION_REFRESH","refreshReducer","ACTION_HMR_REFRESH","hmrRefreshReducer","ACTION_SERVER_ACTION","serverActionReducer","Error","serverReducer","_action","window"],"mappings":";;;+BA4DaA,WAAAA;;;eAAAA;;;oCArDN;iCAMyB;oCACG;gCACJ;gCACA;mCACG;qCACE;AAEpC;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKC,oBAAAA,eAAe;YAAE;gBACpB,OAAOC,CAAAA,GAAAA,iBAAAA,eAAe,EAACJ,OAAOC;YAChC;QACA,KAAKI,oBAAAA,mBAAmB;YAAE;gBACxB,OAAOC,CAAAA,GAAAA,oBAAAA,kBAAkB,EAACN,OAAOC;YACnC;QACA,KAAKM,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACR,OAAOC;YAC/B;QACA,KAAKQ,oBAAAA,cAAc;YAAE;gBACnB,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAACV,OAAOC;YAC/B;QACA,KAAKU,oBAAAA,kBAAkB;YAAE;gBACvB,OAAOC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACZ,OAAOC;YAClC;QACA,KAAKY,oBAAAA,oBAAoB;YAAE;gBACzB,OAAOC,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACd,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,OAAA,cAA2B,CAA3B,IAAIc,MAAM,mBAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAA0B;IACpC;AACF;AAEA,SAASC,cACPhB,KAA2B,EAC3BiB,OAAuB;IAEvB,OAAOjB;AACT;AAGO,MAAMF,UACX,OAAOoB,WAAW,cAAcF,gBAAgBjB","ignoreList":[0]}},
    {"offset": {"line": 7463, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch(\n        {\n          type: ACTION_REFRESH,\n          origin: window.location.origin,\n        },\n        setState\n      )\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        case PrefetchKind.TEMPORARY: {\n          // This concept doesn't exist in the segment cache implementation.\n          return\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n        origin: window.location.origin,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n          origin: window.location.origin,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","origin","window","location","prevState","state","payload","actionResult","handleResult","nextState","discarded","ACTION_SERVER_ACTION","didRevalidate","resolve","isThenable","then","err","reject","dispatchAction","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","globalActionQueue","initialState","instrumentationHooks","result","reducer","onRouterTransitionStart","Error","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","process","env","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","historyState","back","history","forward","prefetch","options","prefetchKind","kind","PrefetchKind","AUTO","fetchStrategy","FetchStrategy","PPR","FULL","Full","TEMPORARY","prefetchWithSegmentCache","nextUrl","tree","onInvalidate","replace","scroll","push","refresh","hmrRefresh","NODE_ENV","ACTION_HMR_REFRESH","router"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7796, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type {\n  CacheNode,\n  FlightDataPath,\n} from '../../../shared/lib/app-router-types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\n\nimport type { AppRouterState } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialRenderedSearch: string\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialRenderedSearch,\n  initialParallelRoutes,\n  location,\n}: InitialRouterStateParameters): AppRouterState {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[0]\n  const loading = initialSeedData?.[2] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: initialParallelRoutes,\n    loading,\n    navigatedAt,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    renderedSearch: initialRenderedSearch,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n\n  return initialState\n}\n"],"names":["createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialRenderedSearch","initialParallelRoutes","location","initialCanonicalUrl","join","normalizedFlightData","getFlightDataPartsFromPath","tree","initialTree","seedData","initialSeedData","head","initialHead","rsc","loading","cache","lazyData","prefetchRsc","prefetchHead","parallelRoutes","canonicalUrl","createHrefFromUrl","addRefreshMarkerToActiveParallelSegments","size","fillLazyItemsTillLeafWithHead","undefined","initialState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","renderedSearch","nextUrl","extractPathFromFlightRouterState","pathname","previousNextUrl","debugInfo"],"mappings":";;;+BAsBgBA,4BAAAA;;;eAAAA;;;mCAjBkB;+CACY;oCACG;iDAGQ;mCACd;AAWpC,SAASA,yBAAyB,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,qBAAqB,EACrBC,QAAQ,EACqB;IAC7B,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBJ,yBAAyBK,IAAI,CAAC;IAE1D,MAAMC,uBAAuBC,CAAAA,GAAAA,mBAAAA,0BAA0B,EAACR,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJS,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGP;IACJ,gGAAgG;IAChG,gDAAgD;IAChD,MAAMQ,MAAMH,iBAAiB,CAAC,EAAE;IAChC,MAAMI,UAAUJ,iBAAiB,CAAC,EAAE,IAAI;IAExC,MAAMK,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbN,MAAM;QACNO,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBlB;QAChBa;QACAjB;IACF;IAEA,MAAMuB,eACJ,AACA,6EAD6E,qEACqE;IAClJlB,WAEImB,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACnB,YAClBC;IAENmB,CAAAA,GAAAA,iCAAAA,wCAAwC,EAACd,aAAaY;IAEtD,yEAAyE;IACzE,IAAInB,0BAA0B,QAAQA,sBAAsBsB,IAAI,KAAK,GAAG;QACtEC,CAAAA,GAAAA,+BAAAA,6BAA6B,EAC3B3B,aACAkB,OACAU,WACAjB,aACAE,iBACAE;IAEJ;IAEA,MAAMc,eAAe;QACnBnB,MAAMC;QACNO;QACAY,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAf;QACAgB,gBAAgBpC;QAChBqC,SAEE,AADA,AACCC,CAAAA,CAAAA,GAAAA,oBAAAA,gCAAgC,EAAC9B,WADoC,KACpBN,UAAUqC,QAAO,KACnE;QACFC,iBAAiB;QACjBC,WAAW;IACb;IAEA,OAAOf;AACT","ignoreList":[0]}},
    {"offset": {"line": 7874, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-link-gc.ts"],"sourcesContent":["export function linkGc() {\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const callback = (mutationList: MutationRecord[]) => {\n      for (const mutation of mutationList) {\n        if (mutation.type === 'childList') {\n          for (const node of mutation.addedNodes) {\n            if (\n              'tagName' in node &&\n              (node as HTMLLinkElement).tagName === 'LINK'\n            ) {\n              const link = node as HTMLLinkElement\n              if (link.dataset.precedence?.startsWith('next')) {\n                const href = link.getAttribute('href')\n                if (href) {\n                  const [resource, version] = href.split('?v=', 2)\n                  if (version) {\n                    const currentOrigin = window.location.origin\n                    const allLinks = [\n                      ...document.querySelectorAll(\n                        'link[href^=\"' + resource + '\"]'\n                      ),\n                      // It's possible that the resource is a full URL or only pathname,\n                      // so we need to remove the alternative href as well.\n                      ...document.querySelectorAll(\n                        'link[href^=\"' +\n                          (resource.startsWith(currentOrigin)\n                            ? resource.slice(currentOrigin.length)\n                            : currentOrigin + resource) +\n                          '\"]'\n                      ),\n                    ] as HTMLLinkElement[]\n\n                    for (const otherLink of allLinks) {\n                      if (otherLink.dataset.precedence?.startsWith('next')) {\n                        const otherHref = otherLink.getAttribute('href')\n                        if (otherHref) {\n                          const [, otherVersion] = otherHref.split('?v=', 2)\n                          if (!otherVersion || +otherVersion < +version) {\n                            // Delay the removal of the stylesheet to avoid FOUC\n                            // caused by `@font-face` rules, as they seem to be\n                            // a couple of ticks delayed between the old and new\n                            // styles being swapped even if the font is cached.\n                            setTimeout(() => {\n                              otherLink.remove()\n                            }, 5)\n                            const preloadLink = document.querySelector(\n                              `link[rel=\"preload\"][as=\"style\"][href=\"${otherHref}\"]`\n                            )\n                            if (preloadLink) {\n                              preloadLink.remove()\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Create an observer instance linked to the callback function\n    const observer = new MutationObserver(callback)\n    observer.observe(document.head, {\n      childList: true,\n    })\n  }\n}\n"],"names":["linkGc","process","env","NODE_ENV","callback","mutationList","mutation","type","node","addedNodes","tagName","link","dataset","precedence","startsWith","href","getAttribute","resource","version","split","currentOrigin","window","location","origin","allLinks","document","querySelectorAll","slice","length","otherLink","otherHref","otherVersion","setTimeout","remove","preloadLink","querySelector","observer","MutationObserver","observe","head","childList"],"mappings":"AAEMC,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAFfH,UAAAA;;;eAAAA;;;AAAT,SAASA;IACd,yEAAyE;IACzE,wCAA2C;QACzC,MAAMI,WAAW,CAACC;YAChB,KAAK,MAAMC,YAAYD,aAAc;gBACnC,IAAIC,SAASC,IAAI,KAAK,aAAa;oBACjC,KAAK,MAAMC,QAAQF,SAASG,UAAU,CAAE;wBACtC,IACE,aAAaD,QACZA,KAAyBE,OAAO,KAAK,QACtC;4BACA,MAAMC,OAAOH;4BACb,IAAIG,KAAKC,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gCAC/C,MAAMC,OAAOJ,KAAKK,YAAY,CAAC;gCAC/B,IAAID,MAAM;oCACR,MAAM,CAACE,UAAUC,QAAQ,GAAGH,KAAKI,KAAK,CAAC,OAAO;oCAC9C,IAAID,SAAS;wCACX,MAAME,gBAAgBC,OAAOC,QAAQ,CAACC,MAAM;wCAC5C,MAAMC,WAAW;+CACZC,SAASC,gBAAgB,CAC1B,iBAAiBT,WAAW;4CAE9B,kEAAkE;4CAClE,qDAAqD;+CAClDQ,SAASC,gBAAgB,CAC1B,iBACGT,CAAAA,SAASH,UAAU,CAACM,iBACjBH,SAASU,KAAK,CAACP,cAAcQ,MAAM,IACnCR,gBAAgBH,QAAO,IAC3B;yCAEL;wCAED,KAAK,MAAMY,aAAaL,SAAU;4CAChC,IAAIK,UAAUjB,OAAO,CAACC,UAAU,EAAEC,WAAW,SAAS;gDACpD,MAAMgB,YAAYD,UAAUb,YAAY,CAAC;gDACzC,IAAIc,WAAW;oDACb,MAAM,GAAGC,aAAa,GAAGD,UAAUX,KAAK,CAAC,OAAO;oDAChD,IAAI,CAACY,gBAAgB,CAACA,eAAe,CAACb,SAAS;wDAC7C,oDAAoD;wDACpD,mDAAmD;wDACnD,oDAAoD;wDACpD,mDAAmD;wDACnDc,WAAW;4DACTH,UAAUI,MAAM;wDAClB,GAAG;wDACH,MAAMC,cAAcT,SAASU,aAAa,CACxC,CAAC,sCAAsC,EAAEL,UAAU,EAAE,CAAC;wDAExD,IAAII,aAAa;4DACfA,YAAYD,MAAM;wDACpB;oDACF;gDACF;4CACF;wCACF;oCACF;gCACF;4BACF;wBACF;oBACF;gBACF;YACF;QACF;QAEA,8DAA8D;QAC9D,MAAMG,WAAW,IAAIC,iBAAiBjC;QACtCgC,SAASE,OAAO,CAACb,SAASc,IAAI,EAAE;YAC9BC,WAAW;QACb;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 7953, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-index.tsx"],"sourcesContent":["import './app-globals'\nimport ReactDOMClient from 'react-dom/client'\nimport React from 'react'\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'\nimport { onRecoverableError } from './react-client-callbacks/on-recoverable-error'\nimport {\n  onCaughtError,\n  onUncaughtError,\n} from './react-client-callbacks/error-boundary-callbacks'\nimport { callServer } from './app-call-server'\nimport { findSourceMapURL } from './app-find-source-map-url'\nimport {\n  type AppRouterActionQueue,\n  createMutableActionQueue,\n} from './components/app-router-instance'\nimport AppRouter from './components/app-router'\nimport type { InitialRSCPayload } from '../shared/lib/app-router-types'\nimport { createInitialRouterState } from './components/router-reducer/create-initial-router-state'\nimport { MissingSlotContext } from '../shared/lib/app-router-context.shared-runtime'\nimport { setAppBuildId } from './app-build-id'\nimport type { StaticIndicatorState } from './dev/hot-reloader/app/hot-reloader-app'\nimport { createInitialRSCPayloadFromFallbackPrerender } from './flight-data-helpers'\n\n/// <reference types=\"react-dom/experimental\" />\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nconst appElement: HTMLElement | Document = document\n\nconst encoder = new TextEncoder()\n\nlet initialServerDataBuffer: (string | Uint8Array)[] | undefined = undefined\nlet initialServerDataWriter: ReadableStreamDefaultController | undefined =\n  undefined\nlet initialServerDataLoaded = false\nlet initialServerDataFlushed = false\n\nlet initialFormStateData: null | any = null\n\ntype FlightSegment =\n  | [isBootStrap: 0]\n  | [isNotBootstrap: 1, responsePartial: string]\n  | [isFormState: 2, formState: any]\n  | [isBinary: 3, responseBase64Partial: string]\n\ntype NextFlight = Omit<Array<FlightSegment>, 'push'> & {\n  push: (seg: FlightSegment) => void\n}\n\ndeclare global {\n  // If you're working in a browser environment\n  interface Window {\n    /**\n     * request ID, dev-only\n     */\n    __next_r?: string\n    __next_f: NextFlight\n  }\n}\n\nfunction nextServerDataCallback(seg: FlightSegment): void {\n  if (seg[0] === 0) {\n    initialServerDataBuffer = []\n  } else if (seg[0] === 1) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(encoder.encode(seg[1]))\n    } else {\n      initialServerDataBuffer.push(seg[1])\n    }\n  } else if (seg[0] === 2) {\n    initialFormStateData = seg[1]\n  } else if (seg[0] === 3) {\n    if (!initialServerDataBuffer)\n      throw new Error('Unexpected server data: missing bootstrap script.')\n\n    // Decode the base64 string back to binary data.\n    const binaryString = atob(seg[1])\n    const decodedChunk = new Uint8Array(binaryString.length)\n    for (var i = 0; i < binaryString.length; i++) {\n      decodedChunk[i] = binaryString.charCodeAt(i)\n    }\n\n    if (initialServerDataWriter) {\n      initialServerDataWriter.enqueue(decodedChunk)\n    } else {\n      initialServerDataBuffer.push(decodedChunk)\n    }\n  }\n}\n\nfunction isStreamErrorOrUnfinished(ctr: ReadableStreamDefaultController) {\n  // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n  return ctr.desiredSize === null || ctr.desiredSize < 0\n}\n\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr: ReadableStreamDefaultController) {\n  if (initialServerDataBuffer) {\n    initialServerDataBuffer.forEach((val) => {\n      ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val)\n    })\n    if (initialServerDataLoaded && !initialServerDataFlushed) {\n      if (isStreamErrorOrUnfinished(ctr)) {\n        ctr.error(\n          new Error(\n            'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'\n          )\n        )\n      } else {\n        ctr.close()\n      }\n      initialServerDataFlushed = true\n      initialServerDataBuffer = undefined\n    }\n  }\n\n  initialServerDataWriter = ctr\n}\n\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function () {\n  if (initialServerDataWriter && !initialServerDataFlushed) {\n    initialServerDataWriter.close()\n    initialServerDataFlushed = true\n    initialServerDataBuffer = undefined\n  }\n  initialServerDataLoaded = true\n}\n\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', DOMContentLoaded, false)\n} else {\n  // Delayed in marco task to ensure it's executed later than hydration\n  setTimeout(DOMContentLoaded)\n}\n\nconst nextServerDataLoadingGlobal = (self.__next_f = self.__next_f || [])\n\n// Consume all buffered chunks and clear the global data array right after to release memory.\n// Otherwise it will be retained indefinitely.\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback)\nnextServerDataLoadingGlobal.length = 0\n\n// Patch its push method so subsequent chunks are handled (but not actually pushed to the array).\nnextServerDataLoadingGlobal.push = nextServerDataCallback\n\nconst readable = new ReadableStream({\n  start(controller) {\n    nextServerDataRegisterWriter(controller)\n  },\n})\nif (process.env.NODE_ENV !== 'production') {\n  // @ts-expect-error\n  readable.name = 'hydration'\n}\n\nlet debugChannel:\n  | { readable?: ReadableStream; writable?: WritableStream }\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL &&\n  typeof window !== 'undefined'\n) {\n  const { createDebugChannel } =\n    require('./dev/debug-channel') as typeof import('./dev/debug-channel')\n\n  debugChannel = createDebugChannel(undefined)\n}\n\nconst clientResumeFetch: Promise<Response> | undefined =\n  // @ts-expect-error\n  window.__NEXT_CLIENT_RESUME\n\nlet initialServerResponse: Promise<InitialRSCPayload>\nif (clientResumeFetch) {\n  initialServerResponse = Promise.resolve(\n    createFromFetch<InitialRSCPayload>(clientResumeFetch, {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n    })\n  ).then(async (fallbackInitialRSCPayload) =>\n    createInitialRSCPayloadFromFallbackPrerender(\n      await clientResumeFetch,\n      fallbackInitialRSCPayload\n    )\n  )\n} else {\n  initialServerResponse = createFromReadableStream<InitialRSCPayload>(\n    readable,\n    {\n      callServer,\n      findSourceMapURL,\n      debugChannel,\n      // @ts-expect-error This is not yet part of the React types\n      startTime: 0,\n    }\n  )\n}\n\nfunction ServerRoot({\n  initialRSCPayload,\n  actionQueue,\n  webSocket,\n  staticIndicatorState,\n}: {\n  initialRSCPayload: InitialRSCPayload\n  actionQueue: AppRouterActionQueue\n  webSocket: WebSocket | undefined\n  staticIndicatorState: StaticIndicatorState | undefined\n}): React.ReactNode {\n  const router = (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorState={initialRSCPayload.G}\n      webSocket={webSocket}\n      staticIndicatorState={staticIndicatorState}\n    />\n  )\n\n  if (process.env.NODE_ENV === 'development' && initialRSCPayload.m) {\n    // We provide missing slot information in a context provider only during development\n    // as we log some additional information about the missing slots in the console.\n    return (\n      <MissingSlotContext value={initialRSCPayload.m}>\n        {router}\n      </MissingSlotContext>\n    )\n  }\n\n  return router\n}\n\nconst StrictModeIfEnabled = process.env.__NEXT_STRICT_MODE_APP\n  ? React.StrictMode\n  : React.Fragment\n\nfunction Root({ children }: React.PropsWithChildren<{}>) {\n  if (process.env.__NEXT_TEST_MODE) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      window.__NEXT_HYDRATED = true\n      window.__NEXT_HYDRATED_AT = performance.now()\n      window.__NEXT_HYDRATED_CB?.()\n    }, [])\n  }\n\n  return children\n}\n\nfunction onDefaultTransitionIndicator() {\n  // TODO: Compose default with user-configureable (e.g. nprogress)\n  // TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30\n  return () => {}\n}\n\nconst reactRootOptions: ReactDOMClient.RootOptions = {\n  onDefaultTransitionIndicator: onDefaultTransitionIndicator,\n  onRecoverableError,\n  onCaughtError,\n  onUncaughtError,\n}\n\nexport type ClientInstrumentationHooks = {\n  onRouterTransitionStart?: (\n    url: string,\n    navigationType: 'push' | 'replace' | 'traverse'\n  ) => void\n}\n\nexport async function hydrate(\n  instrumentationHooks: ClientInstrumentationHooks | null,\n  assetPrefix: string\n) {\n  let staticIndicatorState: StaticIndicatorState | undefined\n  let webSocket: WebSocket | undefined\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { createWebSocket } =\n      require('./dev/hot-reloader/app/web-socket') as typeof import('./dev/hot-reloader/app/web-socket')\n\n    staticIndicatorState = { pathname: null, appIsrManifest: null }\n    webSocket = createWebSocket(assetPrefix, staticIndicatorState)\n  }\n  const initialRSCPayload = await initialServerResponse\n  // setAppBuildId should be called only once, during JS initialization\n  // and before any components have hydrated.\n  setAppBuildId(initialRSCPayload.b)\n\n  const initialTimestamp = Date.now()\n  const actionQueue: AppRouterActionQueue = createMutableActionQueue(\n    createInitialRouterState({\n      navigatedAt: initialTimestamp,\n      initialFlightData: initialRSCPayload.f,\n      initialCanonicalUrlParts: initialRSCPayload.c,\n      initialRenderedSearch: initialRSCPayload.q,\n      initialParallelRoutes: new Map(),\n      location: window.location,\n    }),\n    instrumentationHooks\n  )\n\n  const reactEl = (\n    <StrictModeIfEnabled>\n      <HeadManagerContext.Provider value={{ appDir: true }}>\n        <Root>\n          <ServerRoot\n            initialRSCPayload={initialRSCPayload}\n            actionQueue={actionQueue}\n            webSocket={webSocket}\n            staticIndicatorState={staticIndicatorState}\n          />\n        </Root>\n      </HeadManagerContext.Provider>\n    </StrictModeIfEnabled>\n  )\n\n  if (document.documentElement.id === '__next_error__') {\n    let element = reactEl\n    // Server rendering failed, fall back to client-side rendering\n    if (process.env.NODE_ENV !== 'production') {\n      const { RootLevelDevOverlayElement } =\n        require('../next-devtools/userspace/app/client-entry') as typeof import('../next-devtools/userspace/app/client-entry')\n\n      // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n      element = (\n        <RootLevelDevOverlayElement>{element}</RootLevelDevOverlayElement>\n      )\n    }\n\n    ReactDOMClient.createRoot(appElement, reactRootOptions).render(element)\n  } else {\n    React.startTransition(() => {\n      ReactDOMClient.hydrateRoot(appElement, reactEl, {\n        ...reactRootOptions,\n        formState: initialFormStateData,\n      })\n    })\n  }\n\n  // TODO-APP: Remove this logic when Float has GC built-in in development.\n  if (process.env.NODE_ENV !== 'production') {\n    const { linkGc } =\n      require('./app-link-gc') as typeof import('./app-link-gc')\n    linkGc()\n  }\n}\n"],"names":["hydrate","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","appElement","document","encoder","TextEncoder","initialServerDataBuffer","undefined","initialServerDataWriter","initialServerDataLoaded","initialServerDataFlushed","initialFormStateData","nextServerDataCallback","seg","Error","enqueue","encode","push","binaryString","atob","decodedChunk","Uint8Array","length","i","charCodeAt","isStreamErrorOrUnfinished","ctr","desiredSize","nextServerDataRegisterWriter","forEach","val","error","close","DOMContentLoaded","readyState","addEventListener","setTimeout","nextServerDataLoadingGlobal","self","__next_f","readable","ReadableStream","start","controller","process","env","NODE_ENV","name","debugChannel","__NEXT_REACT_DEBUG_CHANNEL","window","createDebugChannel","require","clientResumeFetch","__NEXT_CLIENT_RESUME","initialServerResponse","Promise","resolve","callServer","findSourceMapURL","then","fallbackInitialRSCPayload","createInitialRSCPayloadFromFallbackPrerender","startTime","ServerRoot","initialRSCPayload","actionQueue","webSocket","staticIndicatorState","router","AppRouter","globalErrorState","G","m","MissingSlotContext","value","StrictModeIfEnabled","__NEXT_STRICT_MODE_APP","React","StrictMode","Fragment","Root","children","__NEXT_TEST_MODE","useEffect","__NEXT_HYDRATED","__NEXT_HYDRATED_AT","performance","now","__NEXT_HYDRATED_CB","onDefaultTransitionIndicator","reactRootOptions","onRecoverableError","onCaughtError","onUncaughtError","instrumentationHooks","assetPrefix","createWebSocket","pathname","appIsrManifest","setAppBuildId","b","initialTimestamp","Date","createMutableActionQueue","createInitialRouterState","navigatedAt","initialFlightData","f","initialCanonicalUrlParts","c","initialRenderedSearch","q","initialParallelRoutes","Map","location","reactEl","HeadManagerContext","Provider","appDir","documentElement","id","element","RootLevelDevOverlayElement","ReactDOMClient","createRoot","render","startTransition","hydrateRoot","formState","linkGc"],"mappings":"AA2KI+C,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;+BAyHPjD,WAAAA;;;eAAAA;;;;;;iEAnSK;gEACT;yBAMX;iDAC4B;oCACA;wCAI5B;+BACoB;qCACM;mCAI1B;oEACe;0CAEmB;+CACN;4BACL;mCAE+B;AAE7D,gDAAgD;AAEhD,MAAMC,2BACJC,SAAAA,wBAA+B;AACjC,MAAMC,kBACJC,SAAAA,eAAsB;AAExB,MAAMC,aAAqCC;AAE3C,MAAMC,UAAU,IAAIC;AAEpB,IAAIC,0BAA+DC;AACnE,IAAIC,0BACFD;AACF,IAAIE,0BAA0B;AAC9B,IAAIC,2BAA2B;AAE/B,IAAIC,uBAAmC;AAuBvC,SAASC,uBAAuBC,GAAkB;IAChD,IAAIA,GAAG,CAAC,EAAE,KAAK,GAAG;QAChBP,0BAA0B,EAAE;IAC9B,OAAO,IAAIO,GAAG,CAAC,EAAE,KAAK,GAAG;QACvB,IAAI,CAACP,yBACH,MAAM,OAAA,cAA8D,CAA9D,IAAIQ,MAAM,sDAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAA6D;QAErE,IAAIN,yBAAyB;YAC3BA,wBAAwBO,OAAO,CAACX,QAAQY,MAAM,CAACH,GAAG,CAAC,EAAE;QACvD,OAAO;YACLP,wBAAwBW,IAAI,CAACJ,GAAG,CAAC,EAAE;QACrC;IACF,OAAO,IAAIA,GAAG,CAAC,EAAE,KAAK,GAAG;QACvBF,uBAAuBE,GAAG,CAAC,EAAE;IAC/B,OAAO,IAAIA,GAAG,CAAC,EAAE,KAAK,GAAG;QACvB,IAAI,CAACP,yBACH,MAAM,OAAA,cAA8D,CAA9D,IAAIQ,MAAM,sDAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAA6D;QAErE,gDAAgD;QAChD,MAAMI,eAAeC,KAAKN,GAAG,CAAC,EAAE;QAChC,MAAMO,eAAe,IAAIC,WAAWH,aAAaI,MAAM;QACvD,IAAK,IAAIC,IAAI,GAAGA,IAAIL,aAAaI,MAAM,EAAEC,IAAK;YAC5CH,YAAY,CAACG,EAAE,GAAGL,aAAaM,UAAU,CAACD;QAC5C;QAEA,IAAIf,yBAAyB;YAC3BA,wBAAwBO,OAAO,CAACK;QAClC,OAAO;YACLd,wBAAwBW,IAAI,CAACG;QAC/B;IACF;AACF;AAEA,SAASK,0BAA0BC,GAAoC;IACrE,6HAA6H;IAC7H,OAAOA,IAAIC,WAAW,KAAK,QAAQD,IAAIC,WAAW,GAAG;AACvD;AAEA,4EAA4E;AAC5E,6EAA6E;AAC7E,oEAAoE;AACpE,sEAAsE;AACtE,qDAAqD;AACrD,4DAA4D;AAC5D,wEAAwE;AACxE,+DAA+D;AAC/D,SAASC,6BAA6BF,GAAoC;IACxE,IAAIpB,yBAAyB;QAC3BA,wBAAwBuB,OAAO,CAAC,CAACC;YAC/BJ,IAAIX,OAAO,CAAC,OAAOe,QAAQ,WAAW1B,QAAQY,MAAM,CAACc,OAAOA;QAC9D;QACA,IAAIrB,2BAA2B,CAACC,0BAA0B;YACxD,IAAIe,0BAA0BC,MAAM;gBAClCA,IAAIK,KAAK,CACP,OAAA,cAEC,CAFD,IAAIjB,MACF,0JADF,qBAAA;2BAAA;gCAAA;kCAAA;gBAEA;YAEJ,OAAO;gBACLY,IAAIM,KAAK;YACX;YACAtB,2BAA2B;YAC3BJ,0BAA0BC;QAC5B;IACF;IAEAC,0BAA0BkB;AAC5B;AAEA,iFAAiF;AACjF,MAAMO,mBAAmB;IACvB,IAAIzB,2BAA2B,CAACE,0BAA0B;QACxDF,wBAAwBwB,KAAK;QAC7BtB,2BAA2B;QAC3BJ,0BAA0BC;IAC5B;IACAE,0BAA0B;AAC5B;AAEA,gDAAgD;AAChD,IAAIN,SAAS+B,UAAU,KAAK,WAAW;IACrC/B,SAASgC,gBAAgB,CAAC,oBAAoBF,kBAAkB;AAClE,OAAO;IACL,qEAAqE;IACrEG,WAAWH;AACb;AAEA,MAAMI,8BAA+BC,KAAKC,QAAQ,GAAGD,KAAKC,QAAQ,IAAI,EAAE;AAExE,6FAA6F;AAC7F,8CAA8C;AAC9CF,4BAA4BR,OAAO,CAACjB;AACpCyB,4BAA4Bf,MAAM,GAAG;AAErC,iGAAiG;AACjGe,4BAA4BpB,IAAI,GAAGL;AAEnC,MAAM4B,WAAW,IAAIC,eAAe;IAClCC,OAAMC,UAAU;QACdf,6BAA6Be;IAC/B;AACF;AACA,wCAA2C;IACzC,mBAAmB;IACnBH,SAASO,IAAI,GAAG;AAClB;AAEA,IAAIC;AAIJ,IACEJ,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBACzBF,QAAQC,GAAG,CAACI,0BAA0B,IACtC,OAAOC,WAAW,aAClB;;AAOF,MAAMG,oBACJ,AACAH,OAAOI,YADY,QACQ;AAE7B,IAAIC;AACJ,IAAIF,mBAAmB;IACrBE,wBAAwBC,QAAQC,OAAO,CACrCzD,gBAAmCqD,mBAAmB;QACpDK,YAAAA,eAAAA,UAAU;QACVC,kBAAAA,qBAAAA,gBAAgB;QAChBX;IACF,IACAY,IAAI,CAAC,OAAOC,4BACZC,CAAAA,GAAAA,mBAAAA,4CAA4C,EAC1C,MAAMT,mBACNQ;AAGN,OAAO;IACLN,wBAAwBzD,yBACtB0C,UACA;QACEkB,YAAAA,eAAAA,UAAU;QACVC,kBAAAA,qBAAAA,gBAAgB;QAChBX;QACA,2DAA2D;QAC3De,WAAW;IACb;AAEJ;AAEA,SAASC,WAAW,EAClBC,iBAAiB,EACjBC,WAAW,EACXC,SAAS,EACTC,oBAAoB,EAMrB;IACC,MAAMC,SAAAA,WAAAA,GACJ,CAAA,GAAA,YAAA,GAAA,EAACC,WAAAA,OAAS,EAAA;QACRJ,aAAaA;QACbK,kBAAkBN,kBAAkBO,CAAC;QACrCL,WAAWA;QACXC,sBAAsBA;;IAI1B,IAAIxB,QAAQC,GAAG,CAACC,QAAQ,gCAAK,iBAAiBmB,kBAAkBQ,CAAC,EAAE;QACjE,oFAAoF;QACpF,gFAAgF;QAChF,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,+BAAAA,kBAAkB,EAAA;YAACC,OAAOV,kBAAkBQ,CAAC;sBAC3CJ;;IAGP;IAEA,OAAOA;AACT;AAEA,MAAMO,sBAAsBhC,QAAQC,GAAG,CAACgC,sBAAsB,KAC1DC,OAAAA,OAAK,CAACC,UAAU,GAChBD,cAAK,CAACE,QAAQ;AAElB,SAASC,KAAK,EAAEC,QAAQ,EAA+B;IACrD,IAAItC,QAAQC,GAAG,CAACsC,gBAAgB,EAAE;;IASlC,OAAOD;AACT;AAEA,SAASQ;IACP,iEAAiE;IACjE,2JAA2J;IAC3J,OAAO,KAAO;AAChB;AAEA,MAAMC,mBAA+C;IACnDD,8BAA8BA;IAC9BE,oBAAAA,oBAAAA,kBAAkB;IAClBC,eAAAA,wBAAAA,aAAa;IACbC,iBAAAA,wBAAAA,eAAe;AACjB;AASO,eAAejG,QACpBkG,oBAAuD,EACvDC,WAAmB;IAEnB,IAAI5B;IACJ,IAAID;IAEJ,IAAIvB,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEmD,eAAe,EAAE,GACvB7C,QAAQ;;;;;QAEVgB,uBAAuB;YAAE8B,UAAU;YAAMC,gBAAgB;QAAK;QAC9DhC,YAAY8B,gBAAgBD,aAAa5B;IAC3C;IACA,MAAMH,oBAAoB,MAAMV;IAChC,qEAAqE;IACrE,2CAA2C;IAC3C6C,CAAAA,GAAAA,YAAAA,aAAa,EAACnC,kBAAkBoC,CAAC;IAEjC,MAAMC,mBAAmBC,KAAKf,GAAG;IACjC,MAAMtB,cAAoCsC,CAAAA,GAAAA,mBAAAA,wBAAwB,EAChEC,CAAAA,GAAAA,0BAAAA,wBAAwB,EAAC;QACvBC,aAAaJ;QACbK,mBAAmB1C,kBAAkB2C,CAAC;QACtCC,0BAA0B5C,kBAAkB6C,CAAC;QAC7CC,uBAAuB9C,kBAAkB+C,CAAC;QAC1CC,uBAAuB,IAAIC;QAC3BC,UAAUjE,OAAOiE,QAAQ;IAC3B,IACApB;IAGF,MAAMqB,UAAAA,WAAAA,GACJ,CAAA,GAAA,YAAA,GAAA,EAACxC,qBAAAA;kBACC,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACyC,iCAAAA,kBAAkB,CAACC,QAAQ,EAAA;YAAC3C,OAAO;gBAAE4C,QAAQ;YAAK;sBACjD,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACtC,MAAAA;0BACC,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAACjB,YAAAA;oBACCC,mBAAmBA;oBACnBC,aAAaA;oBACbC,WAAWA;oBACXC,sBAAsBA;;;;;IAOhC,IAAIjE,SAASqH,eAAe,CAACC,EAAE,KAAK,kBAAkB;QACpD,IAAIC,UAAUN;QACd,8DAA8D;QAC9D,IAAIxE,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;YACzC,MAAM,EAAE6E,0BAA0B,EAAE,GAClCvE,QAAQ;YAEV,kFAAkF;YAClFsE,UAAAA,WAAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,4BAAAA;0BAA4BD;;QAEjC;QAEAE,QAAAA,OAAc,CAACC,UAAU,CAAC3H,YAAYyF,kBAAkBmC,MAAM,CAACJ;IACjE,OAAO;QACL5C,OAAAA,OAAK,CAACiD,eAAe,CAAC;YACpBH,QAAAA,OAAc,CAACI,WAAW,CAAC9H,YAAYkH,SAAS;gBAC9C,GAAGzB,gBAAgB;gBACnBsC,WAAWtH;YACb;QACF;IACF;IAEA,yEAAyE;IACzE,IAAIiC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;QACzC,MAAM,EAAEoF,MAAM,EAAE,GACd9E,QAAQ;QACV8E;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 8224, "column": 0}, "map": {"version":3,"sources":["file:///app/node_modules/next/src/client/app-next-turbopack.ts"],"sourcesContent":["import { appBootstrap } from './app-bootstrap'\nimport { isRecoverableError } from './react-client-callbacks/on-recoverable-error'\n\nwindow.next.turbopack = true\n;(self as any).__webpack_hash__ = ''\n\n// eslint-disable-next-line @next/internal/typechecked-require\nconst instrumentationHooks = require('../lib/require-instrumentation-client')\n\nappBootstrap((assetPrefix) => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  try {\n    hydrate(instrumentationHooks, assetPrefix)\n  } finally {\n    if (process.env.NODE_ENV !== 'production') {\n      const enableCacheIndicator = process.env.__NEXT_CACHE_COMPONENTS\n      const { getOwnerStack } =\n        require('../next-devtools/userspace/app/errors/stitched-error') as typeof import('../next-devtools/userspace/app/errors/stitched-error')\n      const { renderAppDevOverlay } =\n        require('next/dist/compiled/next-devtools') as typeof import('next/dist/compiled/next-devtools')\n      renderAppDevOverlay(\n        getOwnerStack,\n        isRecoverableError,\n        enableCacheIndicator\n      )\n    }\n  }\n})\n"],"names":["window","next","turbopack","self","__webpack_hash__","instrumentationHooks","require","appBootstrap","assetPrefix","hydrate","process","env","NODE_ENV","enableCacheIndicator","__NEXT_CACHE_COMPONENTS","getOwnerStack","renderAppDevOverlay","isRecoverableError"],"mappings":"AAcQU,QAAQC,GAAG,CAACC,QAAQ,KAAK;;;;;8BAdJ;oCACM;AAEnCZ,OAAOC,IAAI,CAACC,SAAS,GAAG;AACtBC,KAAaC,gBAAgB,GAAG;AAElC,8DAA8D;AAC9D,MAAMC,uBAAuBC,QAAQ;AAErCC,CAAAA,GAAAA,cAAAA,YAAY,EAAC,CAACC;IACZ,MAAM,EAAEC,OAAO,EAAE,GAAGH,QAAQ;IAC5B,IAAI;QACFG,QAAQJ,sBAAsBG;IAChC,SAAU;QACR,wCAA2C;YACzC,MAAMK,uBAAuBH,QAAQC,GAAG,CAACG,uBAAuB;YAChE,MAAM,EAAEC,aAAa,EAAE,GACrBT,QAAQ;YACV,MAAM,EAAEU,mBAAmB,EAAE,GAC3BV,QAAQ;YACVU,oBACED,eACAE,oBAAAA,kBAAkB,EAClBJ;QAEJ;IACF;AACF","ignoreList":[0]}}]
}